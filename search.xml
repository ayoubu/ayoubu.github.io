<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python之字典</title>
    <url>/archives/46747.html</url>
    <content><![CDATA[<h2 id="Python-字典-Dictionary"><a href="#Python-字典-Dictionary" class="headerlink" title="Python 字典(Dictionary)"></a>Python 字典(Dictionary)</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。Python中的字典是唯一的<strong>映射类型</strong>，与之对应的列表、元组等都为序列类型。</p>
<p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个键值对之间用逗号 <strong>,</strong> 分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：<code>d = &#123;key1 : value1, key2 : value2 &#125;</code>，索引的时候直接使用key值就行。</p>
<a id="more"></a>

<h2 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h2><p>一般情况直接使用上面所说的键值对的方式创建，也可以使用dict的构造函数进行创建。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1=dict(((<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;C&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;D&#x27;</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;D&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 也可以使用下面这种赋值的，方式，但是这种key值不能为数值类型，不然会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = dict(a = <span class="string">&#x27;A&#x27;</span>, b = <span class="string">&#x27;B&#x27;</span>, c = <span class="string">&#x27;C&#x27;</span>, d = <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;D&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict2 = dict(<span class="number">1</span> = <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span> = <span class="string">&#x27;B&#x27;</span>, <span class="number">3</span> = <span class="string">&#x27;C&#x27;</span>, <span class="number">4</span> = <span class="string">&#x27;D&#x27;</span>) <span class="comment">#错误示范</span></span><br><span class="line">SyntaxError: expression cannot contain assignment, perhaps you meant &quot;==&quot;?</span><br></pre></td></tr></table></figure>

<p>通过字典的键修改相应的值，如果键存在则会进行修改，如果不存在，则会添加新的键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3=&#123;<span class="string">&#x27;大宝&#x27;</span>:<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;小宝&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3[<span class="string">&#x27;小宝&#x27;</span>]=<span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;<span class="string">&#x27;大宝&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>: <span class="string">&#x27;女&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3[<span class="string">&#x27;小小宝&#x27;</span>] = <span class="string">&#x27;未知&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;<span class="string">&#x27;大宝&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>: <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;小小宝&#x27;</span>: <span class="string">&#x27;未知&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典的内置方法"><a href="#字典的内置方法" class="headerlink" title="字典的内置方法"></a>字典的内置方法</h2><h3 id="fromkeys-seq-val"><a href="#fromkeys-seq-val" class="headerlink" title="fromkeys(seq[,val])"></a>fromkeys(seq[,val])</h3><p>创建一个<strong>新字典</strong>，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;&#125;        <span class="comment"># 创建一个空字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1.fromkeys((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))        <span class="comment">#以1，2，3作为键创建一个新的字典</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="literal">None</span>, <span class="number">2</span>: <span class="literal">None</span>, <span class="number">3</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1.fromkeys((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="string">&#x27;大宝&#x27;</span>)    <span class="comment">#以1，2，3作为键创建一个新的字典，并初始化value为‘大宝’</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;大宝&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;大宝&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;大宝&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1.fromkeys((<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;小宝&#x27;</span>)    <span class="comment">#想修改值，但实际上是重新创建了个新字典</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;小宝&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;小宝&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h3><p>访问字典中的所有键(key)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = dict.fromkeys((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">    print(key)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><p>访问字典中的所有值(value)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = dict.fromkeys((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">    print(value)</span><br><span class="line">大宝</span><br><span class="line">大宝</span><br><span class="line">大宝</span><br><span class="line">大宝</span><br><span class="line">大宝</span><br></pre></td></tr></table></figure>

<h3 id="items"><a href="#items" class="headerlink" title="items()"></a>items()</h3><p>将键值对先组成一个元组，再生成一个所有元组的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = dict.fromkeys((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),<span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> dict1.items():</span><br><span class="line">    print(item)    </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;大宝&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>当直接访问字典中不存在的键的时候，会报错，此时可以用get方法，如果访问的是不存在的键，会返回None。也可以使用in或者not in进行判断，和序列不同，字典在使用in时，查找的是键，而不是value。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>清空一个字典时，可以调用clear方法。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h3><p>copy方法是浅拷贝。调用copy方法会在内存上重新复制一份数据。</p>
<h3 id="pop-和popitem"><a href="#pop-和popitem" class="headerlink" title="pop()和popitem()"></a>pop()和popitem()</h3><p>pop(key)是通过键取出相应的值。popitem是随机取一组键值出来。</p>
<h3 id="update-dict"><a href="#update-dict" class="headerlink" title="update(dict)"></a>update(dict)</h3><p>update方法是用一个字典去更新另一个字典的值。</p>
<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>Python中集合的定义和字典很类似，只不过集合中的元素不是以键值对的方式出现的。空集合被默认定义为字典。</p>
<h3 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h3><ul>
<li>集合中的数据都是唯一的，会自动合并重复的数据。</li>
<li>集合是不能通过下标进行索引的。</li>
<li>集合中的数据是无序的。</li>
</ul>
<h3 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h3><ul>
<li>第一种是直接把一堆元素用花括号括起来</li>
<li>一种是使用set()工厂函数，set函数中可以传入列表，元组，字符串。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1 = set(<span class="string">&quot;I love you&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set1</span><br><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问集合中的值"><a href="#访问集合中的值" class="headerlink" title="访问集合中的值"></a>访问集合中的值</h3><ul>
<li>可以使用for把集合中的数据一个个读出来。</li>
<li>可以通过in和not in判断一个元素是否在集合中已经存在。</li>
</ul>
<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>通过<code>frozenset()</code>可以 定义一个不可变集合，即集合内的元素不能更改。</p>
<h3 id="集合内置方法"><a href="#集合内置方法" class="headerlink" title="集合内置方法"></a>集合内置方法</h3><table>
<thead>
<tr>
<th>集合 (s). 方法名</th>
<th>等价符号</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>s.issubset(t)</td>
<td>s &lt;= t</td>
<td>子集测试（允许不严格意义上的子集）：s 中所有的元素都是 t 的成员</td>
</tr>
<tr>
<td></td>
<td>s &lt; t</td>
<td>子集测试（严格意义上）：s != t 而且 s 中所有的元素都是 t 的成员</td>
</tr>
<tr>
<td>s.issuperset(t)</td>
<td>s &gt;= t</td>
<td>超集测试（允许不严格意义上的超集）：t 中所有的元素都是 s 的成员</td>
</tr>
<tr>
<td></td>
<td>s &gt; t</td>
<td>超集测试（严格意义上）：s != t 而且 t 中所有的元素都是 s 的成员</td>
</tr>
<tr>
<td>s.union(t)</td>
<td>s | t</td>
<td>合并操作：s “或” t 中的元素</td>
</tr>
<tr>
<td>s.intersection(t)</td>
<td>s &amp; t</td>
<td>交集操作：s “与” t 中的元素</td>
</tr>
<tr>
<td>s.difference</td>
<td>s - t</td>
<td>差分操作：在 s 中存在，在 t 中不存在的元素</td>
</tr>
<tr>
<td>s.symmetric_difference(t)</td>
<td>s ^ t</td>
<td>对称差分操作：s “或” t 中的元素，但不是 s 和 t 共有的元素</td>
</tr>
<tr>
<td>s.copy()</td>
<td></td>
<td>返回 s 的拷贝（浅复制）</td>
</tr>
<tr>
<td><strong>以下方法仅适用于可变集合</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s.update</td>
<td>s |= t</td>
<td>将 t 中的元素添加到 s 中</td>
</tr>
<tr>
<td>s.intersection_update(t)</td>
<td>s &amp;= t</td>
<td>交集修改操作：s 中仅包括 s 和 t 中共有的成员</td>
</tr>
<tr>
<td>s.difference_update(t)</td>
<td>s -= t</td>
<td>差修改操作：s 中包括仅属于 s 但不属于 t 的成员</td>
</tr>
<tr>
<td>s.symmetric_difference_update(t)</td>
<td>s ^= t</td>
<td>对称差分修改操作：s 中包括仅属于 s 或仅属于 t 的成员</td>
</tr>
<tr>
<td>s.add(obj)</td>
<td></td>
<td>加操作：将 obj 添加到 s</td>
</tr>
<tr>
<td>s.remove(obj)</td>
<td></td>
<td>删除操作：将 obj 从 s 中删除，如果 s 中不存在 obj，将引发异常</td>
</tr>
<tr>
<td>s.discard(obj)</td>
<td></td>
<td>丢弃操作：将 obj 从 s 中删除，如果 s 中不存在 obj，也没事儿^_^</td>
</tr>
<tr>
<td>s.pop()</td>
<td></td>
<td>弹出操作：移除并返回 s 中的任意一个元素</td>
</tr>
<tr>
<td>s.clear()</td>
<td></td>
<td>清除操作：清除 s 中的所有元素</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字典</tag>
        <tag>Dictionary</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>python之list</title>
    <url>/archives/17219.html</url>
    <content><![CDATA[<h2 id="List的结构"><a href="#List的结构" class="headerlink" title="List的结构"></a>List的结构</h2><p>Python中的list是以栈这种数据结构存储的，因此包含一些栈的特性。List中可以存放任何数据以及对象。</p>
<h2 id="向List中添加元素"><a href="#向List中添加元素" class="headerlink" title="向List中添加元素"></a>向List中添加元素</h2><h3 id="append-方法"><a href="#append-方法" class="headerlink" title="append() 方法"></a>append() 方法</h3><p>向一个列表中添加一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>]</span><br><span class="line">l.append(<span class="string">&#x27;小宝&#x27;</span>)   <span class="comment">#append 只能接受一个参数</span></span><br><span class="line">&gt;&gt;&gt;l</span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>,<span class="string">&#x27;小宝&#x27;</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="extend-方法"><a href="#extend-方法" class="headerlink" title="extend() 方法"></a>extend() 方法</h3><p>该方法也是扩展列表的方法，只不过是用另一个列表进行扩展，也可以理解为把一个列表添加到另一个列表的后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>,<span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">l.extend([<span class="number">91</span>,<span class="number">99</span>])</span><br><span class="line">&gt;&gt;&gt;l</span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>,<span class="string">&#x27;小宝&#x27;</span>,<span class="number">91</span>,<span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<h3 id="insert-方法"><a href="#insert-方法" class="headerlink" title="insert() 方法"></a>insert() 方法</h3><p>前两个方法是在列表后面添加元素，有时需要在指定位置添加元素，此时就需要用到insert()方法了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>,<span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">l.insert(<span class="number">1</span>,<span class="number">91</span>) <span class="comment">#在l中的第一个位置插入91</span></span><br><span class="line">&gt;&gt;&gt;l</span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>,<span class="number">91</span>,<span class="string">&#x27;小宝&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="从List中删除元素"><a href="#从List中删除元素" class="headerlink" title="从List中删除元素"></a>从List中删除元素</h2><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">l.remove(<span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line"><span class="comment">#此时列表为 l = [&#x27;小宝&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="语句-del"><a href="#语句-del" class="headerlink" title="语句 del()"></a>语句 del()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>] <span class="comment">#删除‘大宝’</span></span><br><span class="line"><span class="keyword">del</span> l  <span class="comment">#删除整个列表</span></span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><p><code>pop()</code> 可以从列表中取出最后一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">you = l.pop()  <span class="comment">#取出列表中的最后一个元素，即：‘小宝’</span></span><br><span class="line"><span class="comment"># pop()取出特定元素</span></span><br><span class="line">me = pop(<span class="number">0</span>)   <span class="comment">#取出列表中的第一个元素，即：‘大宝’</span></span><br></pre></td></tr></table></figure>

<h2 id="列表的切片操作（slice）"><a href="#列表的切片操作（slice）" class="headerlink" title="列表的切片操作（slice）"></a>列表的切片操作（slice）</h2><p>前面的操作只是用来处理列表中的单个元素，而列表的切片操作是用来处理多个元素的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>]</span><br><span class="line">&gt;&gt;&gt;l[<span class="number">1</span>:<span class="number">3</span>]   <span class="comment">#取出数组中第一个到第三个元素</span></span><br><span class="line">[<span class="number">91</span>,<span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;l[:<span class="number">3</span>]  <span class="comment">#取出从开始到第三个元素</span></span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;l[<span class="number">1</span>:]  <span class="comment">#取出从第一个到数据末尾的所有元素</span></span><br><span class="line">[<span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>]</span><br><span class="line">&gt;&gt;&gt;l[:]  <span class="comment">#相当于拷贝当前列表</span></span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<h2 id="列表中的一些常用操作符"><a href="#列表中的一些常用操作符" class="headerlink" title="列表中的一些常用操作符"></a>列表中的一些常用操作符</h2><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><p>两个列表进行比较会从第一个元素开始比，相等时才会跳到下一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">list2 = [<span class="number">234</span>,<span class="number">123</span>]</span><br><span class="line">list3 = [<span class="number">123</span>,<span class="number">123</span>]</span><br><span class="line">&gt;&gt;&gt;list1 &gt; list2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;list1 &gt; list3</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="连接操作符"><a href="#连接操作符" class="headerlink" title="连接操作符"></a>连接操作符</h3><p>列表可以相加，从而实现两个列表的连接。但是加法操作不能实现向列表中添加新元素的操作。为了规范期间最好不要使用列表的加法操作来拼接两个列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">list2 = [<span class="number">234</span>,<span class="number">123</span>]</span><br><span class="line">&gt;&gt;&gt;list1 + <span class="number">789</span></span><br><span class="line">error</span><br><span class="line">&gt;&gt;&gt;list1 + list2</span><br><span class="line">[<span class="number">123</span>,<span class="number">456</span>,<span class="number">234</span>,<span class="number">123</span>]</span><br></pre></td></tr></table></figure>

<h3 id="重复操作符"><a href="#重复操作符" class="headerlink" title="重复操作符"></a>重复操作符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">&gt;&gt;&gt;list1 * <span class="number">3</span>  <span class="comment">#列表乘一个数，相当于将一个列表复制几次</span></span><br><span class="line">[<span class="number">123</span>,<span class="number">456</span>,<span class="number">123</span>,<span class="number">456</span>,<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">&gt;&gt;&gt;list1 *= <span class="number">3</span>  <span class="comment">#复合操作，相当于将一个列表复制3次，然后再放进原列表</span></span><br><span class="line">&gt;&gt;&gt;list1</span><br><span class="line">[<span class="number">123</span>,<span class="number">456</span>,<span class="number">123</span>,<span class="number">456</span>,<span class="number">123</span>,<span class="number">456</span>]</span><br></pre></td></tr></table></figure>

<h3 id="成员关系操作符"><a href="#成员关系操作符" class="headerlink" title="成员关系操作符"></a>成员关系操作符</h3><p>成员关系操作符就是判断成员和列表的关系。这种判断只能在同一个维度的列表中进行，不能判断嵌套列表中的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">123</span>,<span class="number">456</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="number">123</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;大宝&#x27;</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;小宝&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> list1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 嵌套列表的情况</span></span><br><span class="line">list2 = [<span class="number">123</span>,<span class="number">456</span>,[<span class="string">&#x27;小宝&#x27;</span>]]</span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;小宝&#x27;</span> <span class="keyword">in</span> list2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 可以用这种方式进行访问</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&#x27;小宝&#x27;</span> <span class="keyword">in</span> list2[<span class="number">2</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="列表的内置函数"><a href="#列表的内置函数" class="headerlink" title="列表的内置函数"></a>列表的内置函数</h2><p>列表的内置函数即列表这个类，官方提供的可用的函数，可以通过<code>dir(list)</code> 这个命令进行查看。</p>
<h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>count() 函数是用来计算列表中某个元素出现的次数的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>, <span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;l.count(<span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;l.count(<span class="string">&#x27;小宝&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>


<h3 id="index-函数"><a href="#index-函数" class="headerlink" title="index() 函数"></a>index() 函数</h3><p>index() 函数是用来查找元素出现的位置的，会返回元素第一次出现的位置。index()函数还可以对查找范围进行限制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>, <span class="string">&#x27;小宝&#x27;</span>,<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;l.index(<span class="string">&#x27;大宝&#x27;</span>)   <span class="comment">#查找列表中&#x27;大宝&#x27;出现的位置</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;l.index(<span class="string">&#x27;小宝&#x27;</span>，<span class="number">3</span>，<span class="number">5</span>)  <span class="comment">#查找从3到5这个区间中&#x27;小宝&#x27;出现的位置</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>reverse() 函数会将列表进行反转，即原来第一个元素会和最后一个元素调换位置，第二个会和倒数第二个元素调换位置，以此类推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>]</span><br><span class="line">&gt;&gt;&gt;l.reverse()</span><br><span class="line">[<span class="number">99</span>,<span class="string">&#x27;小宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;大宝&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort() 函数是用于对列表进行排序的函数。sort()函数可以对纯数字或者对纯字符的列表进行排序，不能对混合的列表进行排序。sort() 函数有三个参数，第一个是要使用的排序算法func，第二个是与该算法对应的key，第三个是reverse，即是否反转（逆序）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">&#x27;af&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;bc&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.sort()</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;af&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>]</span><br><span class="line">l=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.sort()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">l=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.sort(reverse=<span class="literal">True</span>)   <span class="comment">#默认reverse=False</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="列表的拷贝"><a href="#列表的拷贝" class="headerlink" title="列表的拷贝"></a>列表的拷贝</h2><p>列表的拷贝分为<strong>深拷贝</strong>和<strong>浅拷贝</strong>，其中深拷贝是会在内存中重新复制一个原数组，而浅拷贝只是给原数组起了个别名而已。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">l1 = l    <span class="comment">#浅拷贝</span></span><br><span class="line">l2 = l[:]    <span class="comment">#深拷贝</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.sort()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>python之字符串</title>
    <url>/archives/49647.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>字符串和元组有点类似，可以把字符串理解为一个由字符组成的元组，字符串一旦创建也是不能更改的。也就是说不能通过索引去更改某个字符。但是，python字符串类提供了很多方法，可以帮我们实现这些操作。</p>
<p>Python 字符串的编写方式多种多样，主要有：Single quotes、Double quotes 还有 Triple quoted 三种形式。</p>
<h3 id="Single-quotes"><a href="#Single-quotes" class="headerlink" title="Single quotes"></a>Single quotes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;I love you&#x27;</span>)</span><br><span class="line">I love you</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Double-quotes"><a href="#Double-quotes" class="headerlink" title="Double quotes"></a>Double quotes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&quot;I love you&quot;</span>)</span><br><span class="line">I love you</span><br></pre></td></tr></table></figure>

<h3 id="Triple-quotes"><a href="#Triple-quotes" class="headerlink" title="Triple quotes"></a>Triple quotes</h3><p>通常，使用三引号字符串来引用多行文本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poetry = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">面朝大海，春暖花开</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">从明天起，做一个幸福的人</span></span><br><span class="line"><span class="string">喂马、劈柴，周游世界&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="混合使用-Single-quotes-和-Double-quotes"><a href="#混合使用-Single-quotes-和-Double-quotes" class="headerlink" title="混合使用 Single quotes 和 Double quotes"></a>混合使用 Single quotes 和 Double quotes</h3><p>一般在我们需要输出带引号的一句话时使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&quot;Let&#x27;s go!&quot;</span>)    <span class="comment">#此时使用单引号，就会有问题</span></span><br><span class="line">Let<span class="string">&#x27;s go!</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(&#x27;</span><span class="string">&quot;Life is short, you need Python.&quot;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&quot;Life is short, you need Python.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串的内置方法"><a href="#字符串的内置方法" class="headerlink" title="字符串的内置方法"></a>字符串的内置方法</h2><p>以下列举了所有的python字符串内置函数。</p>
<table>
<thead>
<tr>
<th>capitalize()</th>
<th>把字符串的第一个字符改为大写</th>
</tr>
</thead>
<tbody><tr>
<td>casefold()</td>
<td>把整个字符串的所有字符改为小写</td>
</tr>
<tr>
<td>center(width)</td>
<td>将字符串居中，并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>count(sub[, start[, end]])</td>
<td>返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。</td>
</tr>
<tr>
<td>encode(encoding=’utf-8’, errors=’strict’)</td>
<td>以 encoding 指定的编码格式对字符串进行编码。</td>
</tr>
<tr>
<td>endswith(sub[, start[, end]])</td>
<td>检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。</td>
</tr>
<tr>
<td>expandtabs([tabsize=8])</td>
<td>把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8。</td>
</tr>
<tr>
<td>find(sub[, start[, end]])</td>
<td>检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。</td>
</tr>
<tr>
<td>index(sub[, start[, end]])</td>
<td>跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。</td>
</tr>
<tr>
<td>isalnum()</td>
<td>如果字符串至少有一个字符并且所有字符都是字母或数字则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isalpha()</td>
<td>如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isdecimal()</td>
<td>如果字符串只包含十进制数字则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isdigit()</td>
<td>如果字符串只包含数字则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>islower()</td>
<td>如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isnumeric()</td>
<td>如果字符串中只包含数字字符，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isspace()</td>
<td>如果字符串中只包含空格，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>istitle()</td>
<td>如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则返回 True，否则返回 False。</td>
</tr>
<tr>
<td>join(sub)</td>
<td>以字符串作为分隔符，插入到 sub 中所有的字符之间。</td>
</tr>
<tr>
<td>ljust(width)</td>
<td>返回一个左对齐的字符串，并使用空格填充至长度为 width 的新字符串。</td>
</tr>
<tr>
<td>lower()</td>
<td>转换字符串中所有大写字符为小写。</td>
</tr>
<tr>
<td>lstrip()</td>
<td>去掉字符串左边的所有空格</td>
</tr>
<tr>
<td>partition(sub)</td>
<td>找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 (‘原字符串’, ‘’, ‘’)</td>
</tr>
<tr>
<td>replace(old, new[, count])</td>
<td>把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。</td>
</tr>
<tr>
<td>rfind(sub[, start[, end]])</td>
<td>类似于 find() 方法，不过是从右边开始查找。</td>
</tr>
<tr>
<td>rindex(sub[, start[, end]])</td>
<td>类似于 index() 方法，不过是从右边开始。</td>
</tr>
<tr>
<td>rjust(width)</td>
<td>返回一个右对齐的字符串，并使用空格填充至长度为 width 的新字符串。</td>
</tr>
<tr>
<td>rpartition(sub)</td>
<td>类似于 partition() 方法，不过是从右边开始查找。</td>
</tr>
<tr>
<td>rstrip()</td>
<td>删除字符串末尾的空格。</td>
</tr>
<tr>
<td>split(sep=None, maxsplit=-1)</td>
<td>不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit 个子字符串，返回切片后的子字符串拼接的列表。</td>
</tr>
<tr>
<td>splitlines(([keepends]))</td>
<td>在输出结果里是否去掉换行符，默认为 False，不包含换行符；如果为 True，则保留换行符。。</td>
</tr>
<tr>
<td>startswith(prefix[, start[, end]])</td>
<td>检查字符串是否以 prefix 开头，是则返回 True，否则返回 False。start 和 end 参数可以指定范围检查，可选。</td>
</tr>
<tr>
<td>strip([chars])</td>
<td>删除字符串前边和后边所有的空格，chars 参数可以定制删除的字符，可选。</td>
</tr>
<tr>
<td>swapcase()</td>
<td>翻转字符串中的大小写。</td>
</tr>
<tr>
<td>title()</td>
<td>返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。</td>
</tr>
<tr>
<td>translate(table)</td>
<td>根据 table 的规则（可以由 str.maketrans(‘a’, ‘b’) 定制）转换字符串中的字符。</td>
</tr>
<tr>
<td>upper()</td>
<td>转换字符串中的所有小写字符为大写。</td>
</tr>
<tr>
<td>zfill(width)</td>
<td>返回长度为 width 的字符串，原字符串右对齐，前边用 0 填充。</td>
</tr>
</tbody></table>
<h3 id="capitalize"><a href="#capitalize" class="headerlink" title="capitalize()"></a>capitalize()</h3><p>将字符串的首字母变成大写形式，然后返回一个新的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&#x27;xiao xie&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.capitalize()</span><br><span class="line"><span class="string">&#x27;Xiao xie&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="casefold"><a href="#casefold" class="headerlink" title="casefold()"></a>casefold()</h3><p>将字符串中的大写全部变成小写，然后返回一个新的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;DaXie&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.casefold()</span><br><span class="line"><span class="string">&#x27;daxie&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="center-width"><a href="#center-width" class="headerlink" title="center(width)"></a>center(width)</h3><p>将字符串居中，并使用空格填充至长度为width 的新字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;center&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.center(<span class="number">40</span>)</span><br><span class="line"><span class="string">&#x27;                 center                 &#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="endswith-sub-start-end"><a href="#endswith-sub-start-end" class="headerlink" title="endswith(sub[,start[,end]])"></a>endswith(sub[,start[,end]])</h3><p>检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;center&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.endswith(<span class="string">&#x27;er&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.endswith(<span class="string">&#x27;er&#x27;</span>,<span class="number">0</span>,<span class="number">4</span>)    <span class="comment">#查找前四个是否以‘er&#x27;结束</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="expandtabs-tabsize-8"><a href="#expandtabs-tabsize-8" class="headerlink" title="expandtabs([tabsize=8])"></a>expandtabs([tabsize=8])</h3><p>把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8。默认参数下有点像print时的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;I\tlove\tyou&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s)</span><br><span class="line">I    love    you</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.expandtabs()</span><br><span class="line"><span class="string">&#x27;I       love    you&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="find-sub-start-end"><a href="#find-sub-start-end" class="headerlink" title="find(sub[,start[,end]])"></a>find(sub[,start[,end]])</h3><p>检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。 与之相应的index(sub)跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。</p>
<p>除此之外还有rfind()，它和find()类似，只不过从右边开始查找，这个是为节省时间。与之对应的index()也有rindex()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;I love you&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">&#x27;he&#x27;</span>)   <span class="comment">#找不到时返回-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">&#x27;you&#x27;</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="join-sub"><a href="#join-sub" class="headerlink" title="join(sub)"></a>join(sub)</h3><p>以字符串作为分隔符，插入到 sub 中所有的字符之间。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;大宝&#x27;</span>   <span class="comment">#把’大宝‘作为分隔符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.join(<span class="string">&#x27;||||&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;|大宝|大宝|大宝|&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="lstrip"><a href="#lstrip" class="headerlink" title="lstrip()"></a>lstrip()</h3><p>去掉字符串左边的所有空格 ，与之对应的还有rstrip()，即去掉字符串右边的所有空格。还有strip()是两头的都去掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;       I love you          &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.lstrip()</span><br><span class="line"><span class="string">&#x27;I love you          &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">&#x27;       I love you&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.strip()</span><br><span class="line"><span class="string">&#x27;I love you&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="partition-sub"><a href="#partition-sub" class="headerlink" title="partition(sub)"></a>partition(sub)</h3><p>找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 (‘原字符串’, ‘’, ‘’) </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Iloveyou&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.partition(<span class="string">&#x27;love&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;you&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="replace-old-new-count"><a href="#replace-old-new-count" class="headerlink" title="replace(old,new[,count])"></a>replace(old,new[,count])</h3><p>把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s =<span class="string">&#x27;大宝，大宝，大宝&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">&#x27;大&#x27;</span>,<span class="string">&#x27;小&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;小宝，小宝，小宝&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">&#x27;大&#x27;</span>,<span class="string">&#x27;小&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;小宝，小宝，大宝&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="split-sep-None-maxsplit-1"><a href="#split-sep-None-maxsplit-1" class="headerlink" title="split(sep=None, maxsplit=-1)"></a>split(sep=None, maxsplit=-1)</h3><p>不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit 个子字符串，返回切片后的子字符串拼接的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;I love you&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.split()    <span class="comment">#以空格切割</span></span><br><span class="line">[<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;you&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s =<span class="string">&#x27;大宝，大宝，大宝&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.split(<span class="string">&#x27;，&#x27;</span>)    <span class="comment">#以’，‘切割</span></span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;大宝&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="translate-table"><a href="#translate-table" class="headerlink" title="translate(table)"></a>translate(table)</h3><p>根据 table 的规则（可以由 str.maketrans(‘a’, ‘b’) 定制）转换字符串中的字符。有点类似replace操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s =<span class="string">&#x27;大宝，大宝，大宝&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.translate(str.maketrans(<span class="string">&#x27;大&#x27;</span>,<span class="string">&#x27;小&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;小宝，小宝，小宝&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><h3 id="format-方法"><a href="#format-方法" class="headerlink" title="format() 方法"></a>format() 方法</h3><p>format()方法可以使用位置参数或者关键字参数，可以单独使用，也可以混合使用，混合使用时位置参数必须在关键字参数之前。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用位置参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; love &#123;1&#125;!&quot;</span>.format(<span class="string">&quot;I&quot;</span>,<span class="string">&quot;you&quot;</span>)</span><br><span class="line"><span class="string">&#x27;I love you!&#x27;</span></span><br><span class="line"><span class="comment"># 使用变量作为参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;a&#125; love &#123;b&#125;!&quot;</span>.format(a = <span class="string">&quot;I&quot;</span>,b = <span class="string">&quot;you&quot;</span>)</span><br><span class="line"><span class="string">&#x27;I love you!&#x27;</span></span><br><span class="line"><span class="comment"># 混合使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; love &#123;b&#125;!&quot;</span>.format(<span class="string">&quot;I&quot;</span>,b = <span class="string">&quot;you&quot;</span>)</span><br><span class="line"><span class="string">&#x27;I love you!&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="小数的格式化打印"><a href="#小数的格式化打印" class="headerlink" title="小数的格式化打印"></a>小数的格式化打印</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;0:.2f&#125; &#123;1&#125;&#x27;</span>.format(<span class="number">0.12345</span>,<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0.12 %&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串格式化符号"><a href="#字符串格式化符号" class="headerlink" title="字符串格式化符号"></a>字符串格式化符号</h2><h3 id="字符串格式化符号含义"><a href="#字符串格式化符号含义" class="headerlink" title="字符串格式化符号含义"></a>字符串格式化符号含义</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>格式化字符及其 ASCII 码</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
<tr>
<td>%d</td>
<td>格式化整数</td>
</tr>
<tr>
<td>%o</td>
<td>格式化无符号八进制数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化无符号十六进制数</td>
</tr>
<tr>
<td>%X</td>
<td>格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td>%f</td>
<td>格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td>%e</td>
<td>用科学计数法格式化浮点数</td>
</tr>
<tr>
<td>%E</td>
<td>作用同 %e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>根据值的大小决定使用 %f 或 %e</td>
</tr>
<tr>
<td>%G</td>
<td>作用同 %g，根据值的大小决定使用 %f 或者 %E</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%c %c %c&#x27;</span> % (<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>)        <span class="comment"># 格式化字符及其 ASCII 码</span></span><br><span class="line"><span class="string">&#x27;a b c&#x27;</span></span><br><span class="line"><span class="string">&#x27;%s %s %s&#x27;</span> % (<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;you&#x27;</span>)    <span class="comment"># 用字符串格式化字符串</span></span><br><span class="line"><span class="string">&#x27;I love you&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%d ,%d&#x27;</span> %(<span class="number">25.66</span>,<span class="number">40</span>)     <span class="comment">#小数也会被格式化成整数</span></span><br><span class="line"><span class="string">&#x27;25 ,40&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%x&#x27;</span>% <span class="number">11</span>    <span class="comment">#格式化为16进制（小写字母）</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%X&#x27;</span>% <span class="number">11</span>    <span class="comment">#格式化为16进制（大写字母）</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%f&#x27;</span>%<span class="number">1.25</span>    <span class="comment">#格式化为浮点数，默认保留小数点后6位，不够会以0补齐</span></span><br><span class="line"><span class="string">&#x27;1.250000&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="格式化操作符辅助命令"><a href="#格式化操作符辅助命令" class="headerlink" title="格式化操作符辅助命令"></a>格式化操作符辅助命令</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>m.n</td>
<td>m 是显示的最小总宽度，n 是小数点后的位数</td>
</tr>
<tr>
<td>-</td>
<td>用于左对齐</td>
</tr>
<tr>
<td>+</td>
<td>在正数前面显示加号（+）</td>
</tr>
<tr>
<td>#</td>
<td>在八进制数前面显示 ‘0o’，在十六进制数前面显示 ‘0x’ 或 ‘0X’</td>
</tr>
<tr>
<td>0</td>
<td>显示的数字前面填充 ‘0’ 取代空格</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%5.1f&#x27;</span> % <span class="number">27.658</span>   <span class="comment">#总长度为5，保留1位小数</span></span><br><span class="line"><span class="string">&#x27; 27.7&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%.2e&#x27;</span>%<span class="number">27.568</span>    <span class="comment">#保留两位小数</span></span><br><span class="line"><span class="string">&#x27;2.76e+01&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%6d&#x27;</span>%<span class="number">1</span>        <span class="comment">#格式化整数，总长度为6</span></span><br><span class="line"><span class="string">&#x27;     1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%-6d&#x27;</span>%<span class="number">1</span>    <span class="comment">#格式化整数，总长度为6，左对齐</span></span><br><span class="line"><span class="string">&#x27;1     &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%+d&#x27;</span>%<span class="number">1</span>        <span class="comment">#格式化显示正整数，并添加符号</span></span><br><span class="line"><span class="string">&#x27;+1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%+d&#x27;</span>%<span class="number">-1</span>    <span class="comment">#格式化显示负整数，并添加符号</span></span><br><span class="line"><span class="string">&#x27;-1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%d&#x27;</span>%<span class="number">-1</span>        <span class="comment">#仅显示负数时可以不用+号</span></span><br><span class="line"><span class="string">&#x27;-1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%#o&#x27;</span>%<span class="number">10</span>    <span class="comment">#格式化显示八进制数，并添加八进制说明符</span></span><br><span class="line"><span class="string">&#x27;0o12&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%#X&#x27;</span>%<span class="number">12</span>    <span class="comment">#格式化显示十六进制数，并添加十六进制说明符</span></span><br><span class="line"><span class="string">&#x27;0XC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%06d&#x27;</span>%<span class="number">1</span>    <span class="comment">#格式化显示整数，以0替换空格</span></span><br><span class="line"><span class="string">&#x27;000001&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="Python-的转义字符及其含义"><a href="#Python-的转义字符及其含义" class="headerlink" title="Python 的转义字符及其含义"></a>Python 的转义字符及其含义</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>发出系统响铃声</td>
</tr>
<tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符（TAB）</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\o</td>
<td>八进制数代表的字符</td>
</tr>
<tr>
<td>\x</td>
<td>十六进制数代表的字符</td>
</tr>
<tr>
<td>\0</td>
<td>表示一个空字符</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>python 之 tuple</title>
    <url>/archives/51299.html</url>
    <content><![CDATA[<h2 id="元组的概念"><a href="#元组的概念" class="headerlink" title="元组的概念"></a>元组的概念</h2><p>元组和列表很相似，只不过元组一旦定义了以后就不能更改了。</p>
<h2 id="创建和访问元组"><a href="#创建和访问元组" class="headerlink" title="创建和访问元组"></a>创建和访问元组</h2><p>元组的创建“，”非常重要。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常规创建元组的方法---()</span></span><br><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)    <span class="comment">#创建一个元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">1</span>]    <span class="comment">#访问元组内的第一个元素</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>[<span class="number">5</span>:]    <span class="comment">#访问索引为5之后的所有元素</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = t[:]     <span class="comment">#拷贝元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个空元组</span></span><br><span class="line">t = ()</span><br><span class="line"><span class="comment">#创建只有一个元素的元组时一定要加,</span></span><br><span class="line">t = (<span class="number">1</span>,)</span><br><span class="line">t = <span class="number">1</span>,    <span class="comment">#这种语法也是合法的</span></span><br><span class="line">t = <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>     <span class="comment">#这种也可以正常创建</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="更新和删除元组"><a href="#更新和删除元组" class="headerlink" title="更新和删除元组"></a>更新和删除元组</h2><p>有时我们可能需要对元组进行一些插入和拼接的操作，这时我们可以用切片的方式来实现。我们一般情况不用删除，python的回收器会自动帮我们删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>)    <span class="comment">#创建一个元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = t[:<span class="number">1</span>] + (<span class="number">91</span>,) + t[<span class="number">1</span>:] + (<span class="number">99</span>,)  <span class="comment">#对元组进行操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">&#x27;大宝&#x27;</span>, <span class="number">91</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">99</span>)    <span class="comment">#最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> t     <span class="comment">#删除元组</span></span><br></pre></td></tr></table></figure>

<h2 id="元组中可以使用的操作符"><a href="#元组中可以使用的操作符" class="headerlink" title="元组中可以使用的操作符"></a>元组中可以使用的操作符</h2><ul>
<li>拼接操作符，即  “ + ”。</li>
<li>重复操作符，即 “ * ”。</li>
<li>关系操作符，即 “ &gt; ,&lt;”。</li>
<li>成员操作符，即：in , not in</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tuple</tag>
        <tag>元组</tag>
      </tags>
  </entry>
  <entry>
    <title>python之函数</title>
    <url>/archives/28278.html</url>
    <content><![CDATA[<h2 id="初识python函数"><a href="#初识python函数" class="headerlink" title="初识python函数"></a>初识python函数</h2><p>在python中定义函数的关键字为<strong>def</strong>，一个完整的函数应该包括函数名、参数、返回值。其中参数和返回值不是必要的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyFirstFunction</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;这是我的第一个函数。&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;&gt; MyFirstFunction()</span><br><span class="line">这是我的第一个函数。</span><br></pre></td></tr></table></figure>

<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>函数定义过程中的参数成为形参，因为它只是一个形式，表示占据一个参数的位置。实参就是在函数调用过程中实际传入的参数，此时参数是有值的，代表一定含义的。</p>
<a id="more"></a>

<h3 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h3><p>函数文档是对函数进行解释说明的，它和注释的最大区别是，函数文档可以通过调用的方式打印出来，具体示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">MyFunc</span>():</span>    <span class="comment">#定义函数</span></span><br><span class="line">    <span class="string">&#x27;这个就是函数文档&#x27;</span></span><br><span class="line">    <span class="comment"># 打印一条消息</span></span><br><span class="line">    print(<span class="string">&#x27;我就是这条消息&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyFunc()</span><br><span class="line">我就是这条消息</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyFunc.__doc__</span><br><span class="line"><span class="string">&#x27;这个就是函数文档&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(MyFunc)    <span class="comment">#也可以通过help看到函数文档</span></span><br><span class="line">Help on function MyFunc <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">MyFunc()</span><br><span class="line">    这个就是函数文档</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是为了防止输入参数顺序错乱，在调用函数时只需要加上参数名就可以了，即使参数顺序和函数定义时不一致，也没有关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">MyFunc</span>(<span class="params">name,sex</span>):</span></span><br><span class="line">    print(name + <span class="string">&#x27;: &#x27;</span>+ sex)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyFunc(sex=<span class="string">&#x27;男&#x27;</span>,name=<span class="string">&#x27;大宝&#x27;</span>)</span><br><span class="line">大宝: 男</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数就是在函数定义的过程中为函数赋的初始值，在程序调用的过程中如果没有给函数传递参数，函数就会使用初始值进行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">MyFunc</span>(<span class="params">name = <span class="string">&#x27;大宝&#x27;</span>,sex=<span class="string">&#x27;男&#x27;</span></span>):</span></span><br><span class="line">    print(name + <span class="string">&#x27;: &#x27;</span>+ sex)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyFunc()    <span class="comment">#此时函数调用不会出现错误</span></span><br><span class="line">大宝: 男</span><br></pre></td></tr></table></figure>

<h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3><p>收集参数是可变长度的参数，需要在参数名前加’*’号来定义，收集参数和普通参数混用的时候，调用函数时需要以关键字的方式进行赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单独使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">MyFunc</span>(<span class="params">*params</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;传入的参数的个数为：&#x27;</span>,len(params))</span><br><span class="line">    print(<span class="string">&#x27;第一个参数为：&#x27;</span>,params[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyFunc(<span class="string">&#x27;大宝&#x27;</span>,<span class="number">91</span>,<span class="string">&#x27;小宝&#x27;</span>,<span class="number">99</span>)</span><br><span class="line">传入的参数的个数为： <span class="number">4</span></span><br><span class="line">第一个参数为： 大宝</span><br><span class="line"><span class="comment"># 混合使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">MyFunc</span>(<span class="params">*params, sex</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;传入的参数的个数为：&#x27;</span>,len(params))</span><br><span class="line">    print(params[<span class="number">0</span>]+<span class="string">&#x27;:&#x27;</span>+ sex)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyFunc(<span class="string">&#x27;大宝&#x27;</span>,<span class="number">91</span>,<span class="string">&#x27;小宝&#x27;</span>,<span class="number">99</span>,sex=<span class="string">&#x27;男&#x27;</span>) <span class="comment">#不加关键字会报错</span></span><br><span class="line">传入的参数的个数为： <span class="number">4</span></span><br><span class="line">大宝:男</span><br></pre></td></tr></table></figure>

<h3 id="函数变量的作用域"><a href="#函数变量的作用域" class="headerlink" title="函数变量的作用域"></a>函数变量的作用域</h3><p>局部变量：在函数内部定义的参数和变量都被称为局部变量，在函数外是无法被调用的。</p>
<p>全局变量：全局变量的作用域是一般是整个当前的代码块。全局变量的值定义后在函数中是可以访问的。</p>
<p>注：如果在函数中想对全局变量进行修改时，python会在函数内部复制一个局部变量给函数修改。但如果我们真的确认了要在函数内对全局变量进行修改，可以使用<code>global</code>关键字重新在函数内定义一下全局变量，此时在函数内对全局变量的修改就会生效。</p>
<h2 id="内嵌函数和闭包"><a href="#内嵌函数和闭包" class="headerlink" title="内嵌函数和闭包"></a>内嵌函数和闭包</h2><h3 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h3><p>在函数内部再嵌套一个函数，此时内部的函数即被称为内嵌函数或者内部函数，python是允许内嵌函数的定义的。内部函数的作用域是在整个外部函数之内的，也就是说想直接在外部函数外的地方直接调用内部函数是行不通的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本的函数嵌套方式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;This is func1...&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;This is func2...&#x27;</span>)</span><br><span class="line">    func2()</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1()</span><br><span class="line">This <span class="keyword">is</span> func1...</span><br><span class="line">This <span class="keyword">is</span> func2...</span><br></pre></td></tr></table></figure>

<h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><p>在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">funx</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funy</span>(<span class="params">y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x*y</span><br><span class="line">    <span class="keyword">return</span> funy</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func = funx(<span class="number">5</span>)     <span class="comment"># 调用funx()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(func)        <span class="comment">#查看funx()的返回值类型，类型是函数即:内部函数funy()</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">func</span>(<span class="params"><span class="number">8</span></span>)        # 像使用函数一样使用<span class="title">func</span></span></span><br><span class="line"><span class="class">40</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">funx</span>(<span class="params"><span class="number">5</span></span>)(<span class="params"><span class="number">8</span></span>)    # 也可以这样直接使用</span></span><br><span class="line"><span class="class">40</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>内部函数也有一个作用域的问题，即它的作用域就是内部函数体内。内部函数体外，外部函数体内的变量对于内部函数来说就是全局变量，因此是无法直接在内部函数体内被修改的。与普通函数修改全局变量不同，内部函数修改外部函数的局部变量时会直接报错，而不是创建一个新的局部变量让内部函数修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误调用示范</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    x = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        x *= x</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> func2()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1()    <span class="comment"># 不能成功调用</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#27&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func1()</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#26&gt;&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> func1</span><br><span class="line">    <span class="keyword">return</span> func2()</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#26&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> func2</span><br><span class="line">    x *= x</span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;x&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p><strong>内部函数调用全局变量的实现方式之一：</strong>对于数值类型的变量来说，是直接存储在栈上的，因此函数执行完之后，变量值也会随之消失。基于此，我们可以选用一些存放在堆上的数据类型（即引用类型），从而避免变量消失。例如我们可以选用列表进行数据存储。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    x = [<span class="number">5</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        x[<span class="number">0</span>] *= x[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> func2()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<p><strong>使用关键字<code>nonlocal</code>:</strong> 即强制将变量声明为非局部变量，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    x = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x *= x</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> func2()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Python 允许使用lambda关键字来创建匿名函数。使用lambda来定义函数，是一种简化的定义函数的方法，有点偷懒的感觉。你不用去定义函数名，和返回值，只需要将定义的lambda语句赋值给一个变量，然后通过使用这个变量就可以实现类似函数实现的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x,y : x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式的作用"><a href="#lambda表达式的作用" class="headerlink" title="lambda表达式的作用"></a>lambda表达式的作用</h3><ul>
<li>Python写一些执行脚本时，使用lambda就可以省下定义函数的过程。比如说我们只是需要写个简单的脚本来管理服务器时间，我们就不需要专门定义一个函数然后再写调用，使用lambda就可以使得代码更加精简。</li>
<li>对于一些抽象且调用次数较少的函数，起名字很麻烦，使用lambda就可以简化这个过程。</li>
<li>增加代码的可读性，不需要再跳转到函数的定义部分查看函数。</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Filter指的是过滤器，filter的默认参数有两个，一个是function or None，另一个是迭代器。当第一个参数为None的时候，默认过滤的是迭代对象中为True的元素，过滤的结果可以转化成list查看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span>, range(<span class="number">20</span>))) <span class="comment">#打印20以内的所有基数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map和filter有点类似，只不过map是用来加工迭代器中的值，而filter是用来过滤迭代器中的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x*x, range(<span class="number">10</span>))) <span class="comment">#求平方</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>简单的说就是再函数内部调用函数自身，从而实现一些迭代的操作。Python为了防止程序进入死循环，设置的默认递归深度为100，可以通过sys模块进行更改。递归两个重要的点：1.函数中调用了自身。2.函数内有终止条件。递归在算法中被称为分治思想。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求阶乘示例，普通方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">n</span>):</span></span><br><span class="line">    num =<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        num *= i</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用递归的写法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * func(n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>斐波那契数列的实现方式：</p>
<ul>
<li>迭代实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    n_2 = <span class="number">1</span>        <span class="comment"># 第n-2的和</span></span><br><span class="line">    n_1 = <span class="number">1</span>        <span class="comment"># 第n-1的和</span></span><br><span class="line">    num = <span class="number">0</span>        <span class="comment"># 当前的和</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            num = n_2 + n_1</span><br><span class="line">            n_2 = n_1</span><br><span class="line">            n_1 = num</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">4</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">12</span>)</span><br><span class="line"><span class="number">144</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<ul>
<li>递归实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt; n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> func(n<span class="number">-2</span>) + func(n<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">4</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">12</span>)</span><br><span class="line"><span class="number">144</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用递归解决汉诺塔问题</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span>(<span class="params">n,x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        print(x, <span class="string">&#x27;---&gt;&#x27;</span>, z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanoi(n<span class="number">-1</span>, x, z, y)        <span class="comment"># 将前n-1个盘子从x移动到y上</span></span><br><span class="line">        print(x, <span class="string">&#x27;---&gt;&#x27;</span>, z)        <span class="comment"># 将最底下的最后一个盘子从x移动到z上</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>, y, x, z)        <span class="comment"># 将y上的n-1个盘子移动到z上</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hanoi(<span class="number">3</span>,<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">X ---&gt; Z</span><br><span class="line">X ---&gt; Y</span><br><span class="line">Z ---&gt; Y</span><br><span class="line">X ---&gt; Z</span><br><span class="line">Y ---&gt; X</span><br><span class="line">Y ---&gt; Z</span><br><span class="line">X ---&gt; Z</span><br></pre></td></tr></table></figure>

<p>对于递归调用的逻辑，下图解释的很清楚，只需要把A,B,C换成X,Y,Z就行。</p>
<p><img src="https://i.imgur.com/AkpP4En.png" alt="n=3时的递归调用图"></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python之模块</title>
    <url>/archives/53523.html</url>
    <content><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是一种更高级的封装，它的作用是封装和组织我们写的代码，将代码分割成不同的模块，便于我们的测试和维护。同时模块也可以方便我们对代码的重用。在python中我们接触过的封装有：</p>
<ul>
<li>容器  —&gt;  数据的封装</li>
<li>函数  —&gt;  语句的封装</li>
<li>类  —&gt;  方法和属性的封装</li>
<li>模块  —&gt;  模块就是程序</li>
</ul>
<a id="more"></a>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在我们编程过程中，我们可能会导入很多模块，模块多了，其中定义的函数名也难免会重复，因此我们在使用模块中的函数时必须加上模块名，以此来区分不同的函数。</p>
<h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>一般情况我们直接使用<code>import 模块名</code>的方式就可以导入了。</p>
<p>有时我们只需要引入一些大模块中的函数，此时我们可以使用<code>from 模块名 import 函数名</code>的方式就可以了。</p>
<p>如果想导入所有模块只需要使用<code>from 模块名 import *</code>这种方式。</p>
<p>如果我们我们导入的模块名太长，我们又需要频繁使用，此时可以使用<code>import 模块名 as 新名字</code>的方式来导入模块，此时我们就可以使用新名字作为命名空间的名字。</p>
<h3 id="if-name-‘-main-‘"><a href="#if-name-‘-main-‘" class="headerlink" title="if __name__ == ‘__main__‘"></a>if __name__ == ‘__main__‘</h3><p>这个在模块中使用是告诉程序，如果模块是直接被执行，则从这里进入并运行。如果模块是被导入使用，则不会运行此处的代码。</p>
<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>Python模块的导入是按照一些搜索路径进行搜索的，默认的搜索路径可以通过<code>sys.path</code>查询，查询结果是一个列表。我们也可以将我们自己写的模块路径添加到这个列表中，此时就可以正常导入我们自己写的模块了。</p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包 (package)"></a>包 (package)</h3><p>如何创建一个包：</p>
<ol>
<li>创建一个文件夹，用于存放相关的模块，文件夹的名字即包的名字。</li>
<li>在文件夹中创建一个<code>__init__.py</code> 的模块文件，内容可以为空。</li>
<li>此时导入模块时，需要<code>包名.模块名</code>的方式才能导入。</li>
</ol>
<h2 id="探索python模块"><a href="#探索python模块" class="headerlink" title="探索python模块"></a>探索python模块</h2><p>首先要学会使用python自带的帮助文档，其中Library Reference中包含了python中的所有自带模块的介绍。</p>
<p>除此之外想要快速了解一个模块时，可以先导入模块，然后使用<code>print(模块名.__doc__)</code>进行查看。</p>
<p>查看模块有哪些可用函数时可以调用<code>dir(模块名)</code>进行查看，如果结果中有<code>&#39;__all__&#39;</code>这个属性，则可以通过<code>模块名.__all__</code>来查看模块对外提供的所有接口函数。这些函数就是可以使用<code>from 模块名 import *</code>的方式导入的所有可用函数。</p>
<p>如果想查看模块原代码所在的位置，则可以通过<code>模块名.__file__</code>进行查看。</p>
<p>除此之外最常用的便是<code>help(模块名)</code>。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>python之类和对象</title>
    <url>/archives/30561.html</url>
    <content><![CDATA[<h2 id="关于类的基本概念"><a href="#关于类的基本概念" class="headerlink" title="关于类的基本概念"></a>关于类的基本概念</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是由<strong>属性</strong>和<strong>方法</strong>组成的，属性描述的是对象的一些固有性质，而方法则是对象可以执行的操作。对象是通过实例化类得到的。</p>
<h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h3><p>面向对象的主要特征为：</p>
<ul>
<li>封装：将对象的属性和方法进行封装，从而起到保护数据的作用。</li>
<li>继承：子类自动共享父类之间数据和方法的机制。</li>
<li>多态：不同对象对同一方法响应不同的方式。</li>
</ul>
<a id="more"></a>

<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>python类中的self相当于C++中的this指针。由于通过类可以实例化多个对象，对于不同对象来说，类中的函数需要处理不同的数据，为了避免不同对象的数据被更改，对象在调用类中的函数时，会将自身作为第一个参数传给函数，此时函数就知道到底是哪一个对象调用了它。</p>
<h3 id="init-self"><a href="#init-self" class="headerlink" title="__init__(self)"></a>__init__(self)</h3><p>__init__(self)是python中的一个魔法方法，它是类中的构造方法，当类在被实例化时，这个方法就会被自动调用，相当于C++中的构造函数。</p>
<h3 id="共有和私有"><a href="#共有和私有" class="headerlink" title="共有和私有"></a>共有和私有</h3><p>在C++中函数或者成员变量可以被定义为共有的或者私有的，从而可以限定对象对某些成员函数的或者变量的访问。而在python中也可以定义私有变量或者私有函数，只需要在变量名前加上两个__就好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    __name = <span class="string">&#x27;大宝&#x27;</span>   <span class="comment"># 此时为私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span>    <span class="comment"># 可以通过共有函数来读取私有变量，即从内部访问</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br></pre></td></tr></table></figure>

<p>但其实python只是对类中的私有成员进行了改名，将其伪装起来了，python类本身并不具有私有的属性。比如上例中的name属性，可以通过p._Person__name进行访问。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过一个使用已经存在的类，从而产生一个新的类的过程被称为继承。被继承的类通常被称为父类，继承后的类被称为子类。子类包含了父类的所有属性和方法。方法：<code>class DerivedClassName(BaseClassName)</code>。定义类时，类名通常要大写。</p>
<p><strong>注：如果子类定义与父类同名的方法或者属性，则会自动覆盖父类对应的方法或属性。</strong></p>
<h3 id="调用未绑定的父类方法"><a href="#调用未绑定的父类方法" class="headerlink" title="调用未绑定的父类方法"></a>调用未绑定的父类方法</h3><p>子类继承父类，但是子类又需要定义自己的初始化函数时，如果直接定义，子类的初始化函数会覆盖父类的初始化函数。此时可以在子类初始化函数中调用父类的初始化函数，来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Class Father:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">        self.y = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Father</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        Father.__init__(self)    <span class="comment">#不调用，无法访问x，y，称为未绑定的父类方法</span></span><br><span class="line">        self.z = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="使用super函数"><a href="#使用super函数" class="headerlink" title="使用super函数"></a>使用super函数</h3><p>与上述方法相比，super函数的优势就是会自动帮你查找父类的相应方法，不用再使用父类的类名加方法的方式。super方法在修改继承关系时是非常方便的，不需要再去代码中修改父类的名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Class Father:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">        self.y = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Father</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super.__init__()    <span class="comment">#直接使用super，会自动传入self</span></span><br><span class="line">        self.z = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>多重继承就是同时继承多个类的属性和方法。语法为：<code>class DerivedClassName(Base1,Base2,Base3):</code>多重继承可能会造成程序混乱，需谨慎使用。</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>有时无法直接从几个类中继承，然后生成一个新类，因为可能会造成从属关系混乱。但是可以用组合的方式创建一个新类，在新类的构造函数中实例化别的类的对象。</p>
<h2 id="类、类对象和实例对象"><a href="#类、类对象和实例对象" class="headerlink" title="类、类对象和实例对象"></a>类、类对象和实例对象</h2><p>类就是一个模具，直接用模具调用的对象就是类对象。通过模具产生的对象被称为实例对象。实例对象创建后修改参数时不会影响到其它实例对象，因为实例对象会创建一个新的参数对象进行修改。但是实例对象创建后没有进行修改时，修改类对象的值时，实例对象的值也会被相应的修改掉。</p>
<p>注：</p>
<ul>
<li>给对象添加属性时，若属性名和方法名重复，则属性名会覆盖方法名。</li>
<li>不要在一个类里面定义出所有能想到的特性和方法，应该利用继承和组合机制进行扩展。</li>
<li>用不同的词性命名，如属性名用名词，方法名用动词。</li>
</ul>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>Python 严格要求方法需要有实例才能被调用，这种限制其实就是Python所谓的绑定概念。</p>
<h2 id="与类相关的内置函数-BIF"><a href="#与类相关的内置函数-BIF" class="headerlink" title="与类相关的内置函数 (BIF)"></a>与类相关的内置函数 (BIF)</h2><p>Python 中会内置一些方法，用来方便用于做一些相关的判断。</p>
<h3 id="issubclass-class，classinfo"><a href="#issubclass-class，classinfo" class="headerlink" title="issubclass(class，classinfo)"></a>issubclass(class，classinfo)</h3><p>判断class是classinfo中的子类吗。注：1.一个类被认为是其自身的子类。2. classinfo可以是类对象组成的元组，只要class与其中任何一个候选类是子类，则返回True。</p>
<h3 id="isinstance-object-classinfo"><a href="#isinstance-object-classinfo" class="headerlink" title="isinstance(object, classinfo)"></a>isinstance(object, classinfo)</h3><p>检查一个对象是某个类的对象吗。注：1. 如果第一个参数不是对象，则永远返回False。2.如果第二个参数不是类或者由类对象组成的元组，会抛出一个TypeError异常。</p>
<h3 id="hasattr-object-‘name’"><a href="#hasattr-object-‘name’" class="headerlink" title="hasattr(object, ‘name’)"></a>hasattr(object, ‘name’)</h3><p>attr = attribute 属性，用来查询某个对象中是否包含某个属性。属性名需要用引号扩起来。</p>
<h3 id="getattr-object-name-default"><a href="#getattr-object-name-default" class="headerlink" title="getattr(object, name[, default])"></a>getattr(object, name[, default])</h3><p>获取对象中的某个属性，若属性存在则会返回属性值，若属性不存在会返回一个attributeError。也可以通过设置可选项，用来返回特定的值。</p>
<h3 id="setattr-object-name-value"><a href="#setattr-object-name-value" class="headerlink" title="setattr(object, name, value)"></a>setattr(object, name, value)</h3><p>用于设置对象中指定属性的值，若属性不存在，则会新建一个属性，并且赋值value和属性。</p>
<h3 id="delattr-object-name"><a href="#delattr-object-name" class="headerlink" title="delattr(object, name)"></a>delattr(object, name)</h3><p>用于删除对象中的指定属性，若属性不存在，则会抛出attributeError的异常。</p>
<h3 id="property-fget-None-fset-None-fdel-None-doc-None"><a href="#property-fget-None-fset-None-fdel-None-doc-None" class="headerlink" title="property(fget=None, fset=None, fdel=None, doc=None)"></a>property(fget=None, fset=None, fdel=None, doc=None)</h3><p>property可以将对象的获取、设置、删除属性的方式赋值给另一个属性，从而方便用户调用，以及后期的代码维护。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Class C:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size = <span class="number">10</span></span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setSize</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.size = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSize</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delSize</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.size</span><br><span class="line">    x = property(getSize, setSize, delSize)   <span class="comment">#将三个函数合二为一</span></span><br><span class="line">c1 = C()</span><br><span class="line">c1.x = <span class="number">18</span>    <span class="comment"># 默认调用setSize()函数</span></span><br><span class="line">c1.x   <span class="comment"># 默认调用getSize()函数</span></span><br><span class="line"><span class="keyword">del</span> c1.x    <span class="comment"># 默认调用delSize()函数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>类</tag>
        <tag>对象</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>python之文件</title>
    <url>/archives/58554.html</url>
    <content><![CDATA[<h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><table>
<thead>
<tr>
<th><strong>打开模式</strong></th>
<th><strong>执行操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>‘r’</td>
<td>以只读方式打开文件（默认）</td>
</tr>
<tr>
<td>‘w’</td>
<td>以写入的方式打开文件，会覆盖已存在的文件</td>
</tr>
<tr>
<td>‘x’</td>
<td>如果文件已经存在，使用此模式打开将引发异常</td>
</tr>
<tr>
<td>‘a’</td>
<td>以写入模式打开，如果文件存在，则在末尾追加写入</td>
</tr>
<tr>
<td>‘b’</td>
<td>以二进制模式打开文件</td>
</tr>
<tr>
<td>‘t’</td>
<td>以文本模式打开（默认）</td>
</tr>
<tr>
<td>‘+’</td>
<td>可读写模式（可添加到其他模式中使用）</td>
</tr>
<tr>
<td>‘U’</td>
<td>通用换行符支持</td>
</tr>
</tbody></table>
<h3 id="open-打开文件"><a href="#open-打开文件" class="headerlink" title="open() 打开文件"></a>open() 打开文件</h3><p>open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)，其中file是文件路径，mode是打开的模式，不同模式会对应不同的操作。具体参考上表。</p>
<h3 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h3><table>
<thead>
<tr>
<th><strong>文件对象方法</strong></th>
<th><strong>执行操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>f.close()</td>
<td>关闭文件</td>
</tr>
<tr>
<td>f.read([size=-1])</td>
<td>从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，然后作为字符串返回</td>
</tr>
<tr>
<td>f.readline([size=-1])</td>
<td>从文件中读取并返回一行（包括行结束符），如果有size有定义则返回size个字符</td>
</tr>
<tr>
<td>f.write(str)</td>
<td>将字符串str写入文件</td>
</tr>
<tr>
<td>f.writelines(seq)</td>
<td>向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象</td>
</tr>
<tr>
<td>f.seek(offset, from)</td>
<td>在文件中移动文件指针，从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节</td>
</tr>
<tr>
<td>f.tell()</td>
<td>返回当前在文件中的位置</td>
</tr>
<tr>
<td>f.truncate([size=file.tell()])</td>
<td>截取文件到size个字节，默认是截取到文件指针当前位置</td>
</tr>
</tbody></table>
<h2 id="文件读取的相关操作"><a href="#文件读取的相关操作" class="headerlink" title="文件读取的相关操作"></a>文件读取的相关操作</h2><ul>
<li>使用f.read([size=-1])读取文件中的数据，其中size为读取的长度，size=-1表示全部读取。数据读取后，数据指针会指向下一个数据的位置，再此读取时会从标签位置进行读取。</li>
<li>f.tell() 返回当前读取文件的数据指针的位置。</li>
<li>f.seek(offset, from)，移动数据指针的位置，offset为移动多少字符。注意对于中文字符来说，一个字占两个字节，但是数据指针可以指向单字节，此时再进行数据读取操作时会出现错误。</li>
<li>可以使用list()将文件数据转换为列表进行访问</li>
<li>可以使用<code>for each_line in f:</code>对文件进行逐行访问，这种方式效率比较高。</li>
</ul>
<h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>文件写入时，打开模式得是以可写的模式打开的。写入后记得关闭文件。</p>
<ul>
<li>f.write(str)，将一个字符串写入至文件。</li>
<li>f.writelines(seq)，将一个可迭代的序列写入到文件，seq可以为一个列表。</li>
</ul>
<h2 id="os模块中关于文件-目录常用的函数使用方法"><a href="#os模块中关于文件-目录常用的函数使用方法" class="headerlink" title="os模块中关于文件/目录常用的函数使用方法"></a>os模块中关于文件/目录常用的函数使用方法</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><table>
<thead>
<tr>
<th><strong>函数名</strong></th>
<th><strong>使用方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>getcwd()</td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td>chdir(path)</td>
<td>改变工作目录</td>
</tr>
<tr>
<td>listdir(path=’.’)</td>
<td>列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录）</td>
</tr>
<tr>
<td>mkdir(path)</td>
<td>创建单层目录，如该目录已存在抛出异常</td>
</tr>
<tr>
<td>makedirs(path)</td>
<td>递归创建多层目录，如该目录已存在抛出异常，注意：’E:\a\b’和’E:\a\c’并不会冲突</td>
</tr>
<tr>
<td>remove(path)</td>
<td>删除文件</td>
</tr>
<tr>
<td>rmdir(path)</td>
<td>删除单层目录，如该目录非空则抛出异常</td>
</tr>
<tr>
<td>removedirs(path)</td>
<td>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常</td>
</tr>
<tr>
<td>rename(old, new)</td>
<td>将文件old重命名为new</td>
</tr>
<tr>
<td>system(command)</td>
<td>运行系统的shell命令</td>
</tr>
<tr>
<td>walk(top)</td>
<td>遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】</td>
</tr>
<tr>
<td></td>
<td><strong>以下是支持路径操作中常用到的一些定义，支持所有平台</strong></td>
</tr>
<tr>
<td>os.curdir</td>
<td>指代当前目录（’.’）</td>
</tr>
<tr>
<td>os.pardir</td>
<td>指代上一级目录（’..’）</td>
</tr>
<tr>
<td>os.sep</td>
<td>输出操作系统特定的路径分隔符（Win下为’\‘，Linux下为’/‘）</td>
</tr>
<tr>
<td>os.linesep</td>
<td>当前平台使用的行终止符（Win下为’\r\n’，Linux下为’\n’）</td>
</tr>
<tr>
<td>os.name</td>
<td>指代当前使用的操作系统（包括：’posix’, ‘nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’）</td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd    <span class="comment"># 获取当前目录</span></span><br><span class="line"><span class="string">&#x27;D:\\StudyProgram\\python3.8&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">&#x27;D:\\Data&#x27;</span>)    <span class="comment"># 改变当前目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">&#x27;D:\\Data&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">&#x27;D:\\StudyProgram\\&#x27;</span>)     <span class="comment"># 列举给定目录下所有文件名</span></span><br><span class="line">[<span class="string">&#x27;Anaconda3&#x27;</span>, <span class="string">&#x27;Blog&#x27;</span>, <span class="string">&#x27;cmake-3.11.0-rc1-win64-x64.msi&#x27;</span>, <span class="string">&#x27;opencv347&#x27;</span>, <span class="string">&#x27;python3.8&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir()  <span class="comment"># 列举当前目录下所有文件名</span></span><br><span class="line">[<span class="string">&#x27;blog&#x27;</span>, <span class="string">&#x27;CacheData&#x27;</span>, <span class="string">&#x27;Code&#x27;</span>, <span class="string">&#x27;Google Cloud&#x27;</span>, <span class="string">&#x27;i4Tools7&#x27;</span>, <span class="string">&#x27;R_workspace&#x27;</span>, <span class="string">&#x27;SecureCRT&#x27;</span>, <span class="string">&#x27;Vmware&#x27;</span>, <span class="string">&#x27;VSCode&#x27;</span>, <span class="string">&#x27;XMind&#x27;</span>, <span class="string">&#x27;YoudaoNote&#x27;</span>, <span class="string">&#x27;印象笔记&#x27;</span>, <span class="string">&#x27;坚果云&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="os-path模块中关于路径常用的函数使用方法"><a href="#os-path模块中关于路径常用的函数使用方法" class="headerlink" title="os.path模块中关于路径常用的函数使用方法"></a><strong>os.path模块中关于路径常用的函数使用方法</strong></h2><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><table>
<thead>
<tr>
<th>basename(path)</th>
<th>去掉目录路径，单独返回文件名</th>
</tr>
</thead>
<tbody><tr>
<td>dirname(path)</td>
<td>去掉文件名，单独返回目录路径</td>
</tr>
<tr>
<td>join(path1[, path2[, …]])</td>
<td>将path1, path2各部分组合成一个路径名</td>
</tr>
<tr>
<td>split(path)</td>
<td>分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在</td>
</tr>
<tr>
<td>splitext(path)</td>
<td>分离文件名与扩展名，返回(f_name, f_extension)元组</td>
</tr>
<tr>
<td>getsize(file)</td>
<td>返回指定文件的尺寸，单位是字节</td>
</tr>
<tr>
<td>getatime(file)</td>
<td>返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td>
</tr>
<tr>
<td>getctime(file)</td>
<td>返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td>
</tr>
<tr>
<td>getmtime(file)</td>
<td>返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td>
</tr>
<tr>
<td></td>
<td><strong>以下为函数返回 True 或 False</strong></td>
</tr>
<tr>
<td>exists(path)</td>
<td>判断指定路径（目录或文件）是否存在</td>
</tr>
<tr>
<td>isabs(path)</td>
<td>判断指定路径是否为绝对路径</td>
</tr>
<tr>
<td>isdir(path)</td>
<td>判断指定路径是否存在且是一个目录</td>
</tr>
<tr>
<td>isfile(path)</td>
<td>判断指定路径是否存在且是一个文件</td>
</tr>
<tr>
<td>islink(path)</td>
<td>判断指定路径是否存在且是一个符号链接</td>
</tr>
<tr>
<td>ismount(path)</td>
<td>判断指定路径是否存在且是一个挂载点</td>
</tr>
<tr>
<td>samefile(path1, paht2)</td>
<td>判断path1和path2两个路径是否指向同一个文件</td>
</tr>
</tbody></table>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(<span class="string">&#x27;D:\\test\\test\\data.txt&#x27;</span>)  <span class="comment"># 仅取出文件名</span></span><br><span class="line"><span class="string">&#x27;data.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="string">&#x27;D:\\test\\test\\data.txt&#x27;</span>) <span class="comment"># 仅取出路径</span></span><br><span class="line"><span class="string">&#x27;D:\\test\\test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;D:\\&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;test&#x27;</span>)  <span class="comment"># 组合成路径，盘符需要加\\</span></span><br><span class="line"><span class="string">&#x27;D:\\test\\test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;D:\\test\\test\\data.txt&#x27;</span>)  <span class="comment"># 分割出最后一个\\后的字符</span></span><br><span class="line">(<span class="string">&#x27;D:\\test\\test&#x27;</span>, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;D:\\test\\test\\&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;D:\\test\\test&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;D:\\test\\test&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;D:\\test&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;D:\\test\\data.txt&#x27;</span>) <span class="comment">#分割文件后缀</span></span><br><span class="line">(<span class="string">&#x27;D:\\test\\data&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pickle-模块的使用"><a href="#pickle-模块的使用" class="headerlink" title="pickle 模块的使用"></a>pickle 模块的使用</h2><p>pickle模块是一个可以将python中的任何数据类型转化为二进制文件的模块。我们可以使用这个模块把一些程序计算过程要用到的数据保存起来，之后使用的时候再从本地读取就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle    <span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="string">&#x27;大宝&#x27;</span>,<span class="string">&#x27;小宝&#x27;</span>,<span class="number">91</span>,<span class="number">90</span>,<span class="string">&#x27;I love you&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle_file = open(<span class="string">&#x27;list1.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)    <span class="comment"># 以写入方式打开文件，后缀可以自己定义</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(list1, pickle_file)    <span class="comment"># 使用dump函数写入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle_file.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle_file = open(<span class="string">&#x27;list1.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)  <span class="comment">#使 用读的方式打开文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = pickle.load(pickle_file) <span class="comment"># 恢复列表数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list2)</span><br><span class="line">[<span class="string">&#x27;大宝&#x27;</span>, <span class="string">&#x27;小宝&#x27;</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="string">&#x27;I love you&#x27;</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>文件</tag>
        <tag>os</tag>
        <tag>os.path</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title>python课后作业002</title>
    <url>/archives/7409.html</url>
    <content><![CDATA[<h3 id="什么是BIF？"><a href="#什么是BIF？" class="headerlink" title="什么是BIF？"></a>什么是BIF？</h3><p>BIF 就是 Built-in Functions，内置函数。为了方便程序员快速编写脚本程序（脚本就是要编程速度快快快！！！），Python 提供了非常丰富的内置函数，我们只需要直接调用即可，例如 print() 的功能是“打印到屏幕”，input() 的作用是接收用户输入（注：Python3 用 input() 取代了 Python2 的 raw_input()，用法如有不懂请看视频讲解）。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>课后作业</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>BIF</tag>
      </tags>
  </entry>
  <entry>
    <title>python之异常处理</title>
    <url>/archives/19524.html</url>
    <content><![CDATA[<h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>程序中的异常是区别于错误存在的，错误往往指的是语法或者逻辑上的，最终导致编译器无法编译通过。而异常往往是由不受控制的输入或者输出导致的。在程序设计过程中，对于一些不受控制的输入，最好是引入异常处理。这样可以增强程序的健壮性，不至于遇到点问题程序就崩溃了。</p>
<h2 id="Python中的异常处理"><a href="#Python中的异常处理" class="headerlink" title="Python中的异常处理"></a>Python中的异常处理</h2><p>和一些高级语言一样，python也引入了try/except/finally语句块来处理异常，除此之外python还有断言(Assertions)来防止一些关键结果出问题。</p>
<a id="more"></a>

<h3 id="python标准异常"><a href="#python标准异常" class="headerlink" title="python标准异常"></a>python标准异常</h3><table>
<thead>
<tr>
<th>AssertionError</th>
<th>断言语句（assert）失败</th>
</tr>
</thead>
<tbody><tr>
<td>AttributeError</td>
<td>尝试访问未知的对象属性</td>
</tr>
<tr>
<td>EOFError</td>
<td>用户输入文件末尾标志EOF（Ctrl+d）</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td>浮点计算错误</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td>generator.close()方法被调用的时候</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块失败的时候</td>
</tr>
<tr>
<td>IndexError</td>
<td>索引超出序列的范围</td>
</tr>
<tr>
<td>KeyError</td>
<td>字典中查找一个不存在的关键字</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户输入中断键（Ctrl+c）</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出（可通过删除对象释放内存）</td>
</tr>
<tr>
<td>NameError</td>
<td>尝试访问一个不存在的变量</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统产生的异常（例如打开一个不存在的文件）</td>
</tr>
<tr>
<td>OverflowError</td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td>StopIteration</td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python的语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab和空格混合使用</td>
</tr>
<tr>
<td>SystemError</td>
<td>Python编译器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>Python编译器进程被关闭</td>
</tr>
<tr>
<td>TypeError</td>
<td>不同类型间的无效操作</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>访问一个未初始化的本地变量（NameError的子类）</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>Unicode相关的错误（ValueError的子类）</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td>Unicode编码时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td>Unicode解码时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td>Unicode转换时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td>除数为零</td>
</tr>
</tbody></table>
<h3 id="捕捉异常可以使用try-except语句"><a href="#捕捉异常可以使用try-except语句" class="headerlink" title="捕捉异常可以使用try/except语句"></a>捕捉异常可以使用try/except语句</h3><p>这种方式的基本语法表达如下所示，except部分可以添加多个except判断。try一旦检测到异常，程序便不会继续执行try中的其它代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span> Exception[<span class="keyword">as</span> reason]:</span><br><span class="line">    出现异常(Exception)后的处理代码</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">&#x27;一个未知文件.txt&#x27;</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> reason:</span><br><span class="line">    print(<span class="string">&#x27;文件不存在...\n错误原因是：&#x27;</span>+ str(reason))</span><br><span class="line"><span class="keyword">except</span> (OSError,TypeError):</span><br><span class="line">    print(<span class="string">&#x27;判断是否有这两种错误中的一种，有就到这。&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&#x27;只要程序有错误，就进入到这里...&#x27;</span>)    <span class="comment">##不推荐这种方式</span></span><br><span class="line">文件不存在...</span><br><span class="line">错误原因是：[Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;一个未知文件.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="try-finally语句"><a href="#try-finally语句" class="headerlink" title="try-finally语句"></a>try-finally语句</h3><p>Finally 可以和try-except语句一起连用，表示无论如何都会执行的代码。这部分代码可以用来保存数据，释放资源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span> Exception[<span class="keyword">as</span> reason]:</span><br><span class="line">    出现异常(Exception)后的处理代码</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    无论如何都会执行的代码。</span><br></pre></td></tr></table></figure>

<h3 id="raise-引出异常"><a href="#raise-引出异常" class="headerlink" title="raise()引出异常"></a>raise()引出异常</h3><p>raise语句的基本语法格式为：<code>raise [exceptionName [(reason)]]</code></p>
<p>raise语句通常由三种常用的用法：</p>
<ol>
<li>raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。</li>
<li>raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。</li>
<li>raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#1&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line">RuntimeError: No active exception to reraise</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#0&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionError</span><br><span class="line">ZeroDivisionError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ZeroDivisionError(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#2&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> ZeroDivisionError(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">ZeroDivisionError: 除数不能为零</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = input(<span class="string">&quot;输入一个数：&quot;</span>)</span><br><span class="line">    <span class="comment">#判断用户输入的是否为数字</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> a.isdigit()):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;a 必须是数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&quot;引发异常：&quot;</span>,repr(e))</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>异常处理</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>写作以及博文管理</title>
    <url>/archives/6783.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我的博客网站已经搭好，在此特别感谢一下<a href="https://tding.top/archives/2bd6d82.html">小丁</a>的分享。我下的是NexT最新的主题，再搭建的过程踩了不少坑，不过大部分问题通过参考他的解决方案都完美解决了，一些小的地方，只要理解了他的解决方式，也都可以用相似的方法解决，具体的我就不在赘述了。</p>
<p>在搭建好博客之后我就想开始我的博客之路了，可是关于怎么去写博客，网上虽然都介绍，但是我感觉都有点简单，对于要经常写博客的同学来说，可能有点不太友好。通过YouTube上的一位UP主<a href="https://www.youtube.com/playlist?list=PLLAZ4kZ9dFpOMJR6D25ishrSedvsguVSm">Mike Dan</a>的分享，我整理出了一些方法，现在记录分享给大家。</p>
<a id="more"></a>

<h2 id="新建一篇博文（post）"><a href="#新建一篇博文（post）" class="headerlink" title="新建一篇博文（post）"></a>新建一篇博文（post）</h2><p>这个是最基础的操作，直接通过以下命令就可以实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new test_post</span><br><span class="line">or</span><br><span class="line">hexo new post test_post</span><br></pre></td></tr></table></figure>

<p>此时会在hexo/source/_post目录下生成一个名为test_post.md文件。此时刷新网站，也会多一个名为test_post的文章（命令必须在网站的根目录（我的是hexo/）才会有效，win10用户可以在hexo/目录下，按住shift+鼠标右键，然后选择 <strong>在此处打开PowerShell</strong> 直接进如此目录）。使用<code>hexo new</code> 命令可以直接新建post是因为我们网站的配置文件中的 <code>default_layout: post</code> 选的是post，需要更改时可以直接在网站配置文件中搜索更改。可以更改为post、page、draft。</p>
<p>新建完成后直接刷新本地的网站首页就可以看到了。</p>
<h2 id="新建一篇草稿（draft）"><a href="#新建一篇草稿（draft）" class="headerlink" title="新建一篇草稿（draft）"></a>新建一篇草稿（draft）</h2><p>在我们写作的过程中，有时我们想先发布到网站上看看效果。此时我们就可以使用草稿这个功能(draft)，即草稿。我们可以使用下列命令来新建一个草稿。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new draft test_draft</span><br></pre></td></tr></table></figure>

<p>此时会在hexo/source/_draft 目录下生成一个名为test_draft的文件。此时在网站主页是看不到这篇文章的，因为它是草稿嘛，想看这个需要使用下面的命令重新启动服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure>

<p>在我们确定文章没问题之后，想将其发布，可以使用以下命令，将其推送至公开的网站首页。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo publish test_draft</span><br></pre></td></tr></table></figure>

<p>此时再刷新网站首页就可以看到了。</p>
<h2 id="新建一个页面（page）"><a href="#新建一个页面（page）" class="headerlink" title="新建一个页面（page）"></a>新建一个页面（page）</h2><p>新建页面操作会生成一个新的普通的网页，这个网页不会直接显示在网站主页上，方法如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>运行命令后会在hexo/source 目录下生成一个名为test 的文件夹，在这个文件夹中会包含一个名为index.md的文件。生的页面可以在本地浏览器中输入：<a href="http://localhost:4000/test/">http://localhost:4000/test/</a> 进行访问。我们主页的<code>关于</code> <code>标签</code> <code>分类</code> 等的跳转页面都是通过这种方式建立的，至于其它用处目前我还不清楚，之后如果发现了它的用法后再来补充。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>我们可以使用 <code>hexo new post or draft or page</code> 的主要原因其实是hexo为我们建立一些常用的模板，这些模板放在hexo/scaffolds目录下。如下图所示。</p>
<p><img src="https://i.imgur.com/2cn9II6.png" alt="模板文件目录"></p>
<p>打开我们最常用的post.md文件，如下图所示，其中第前两行表示名称(title)和日期(date)可以按照这种方式设置为自动填写，第三行的标签(tags)可以手动填写。</p>
<p><img src="https://i.imgur.com/gmevrXa.png" alt="post.md文件"></p>
<p>有时候我们还想添加一些其它的信息，例如分类(categories)，置顶信息（top,这个需要安装特定的插件来实现）等。此时我们可以直接在这个文件中添加，这样以后生成新的博文的时候就会默认包含这些你添加的信息了。</p>
<p>除此之外我们还可以添加一些其他的默认模板，比如我最近在学习python我可以添加一个默认模板用于写python相关的博文，这样我就可以直接通过<code>hexo new python test_python</code> 来生成了（python为我的模板名称）。下图为我建的用于生成python文章的模板。</p>
<p><img src="https://i.imgur.com/cX6dP28.png" alt="python模板"><br>其中tags以列表的方式可以添加多个，而categories列表中是表示文章的类别，比如：<code>[python,learn python]</code> 就表示这篇文章是在python 类别下的 learn python 类别中。</p>
<h2 id="删除博文"><a href="#删除博文" class="headerlink" title="删除博文"></a>删除博文</h2><p>删除文章比较简单，先停止本地运行的服务，然后直接在hexo/source/_posts目录下找到相应文件直接删除，再运行<code>hexo g</code> 命令重新生成，最后再启动本地服务，发现博文已经删除。如果全部删除了，打开首页会有问题，重新创建一个，再打开首页就没问题了。</p>
<p>本文主要介绍了使用hexo进行博文写作和管理文章的方法。其中管理文章主要体现在对tags和categories的应用。目前就想到这么多，以后想到再补充。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博文创建及管理</tag>
      </tags>
  </entry>
  <entry>
    <title>python之魔法方法</title>
    <url>/archives/52592.html</url>
    <content><![CDATA[<h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><h3 id="init-self-…-方法"><a href="#init-self-…-方法" class="headerlink" title="__init__(self,[, …]) 方法"></a>__init__(self,[, …]) 方法</h3><p>魔法方法总是被双下划线包围，例如__init__方法。魔法方法代表了python的强大之处。</p>
<p>python中的默认构造函数为__init__(self,[, …]) 方法，init函数的返回值必须为None，否则会产生TpyeError的错误。</p>
<h3 id="new-cls-…-方法"><a href="#new-cls-…-方法" class="headerlink" title="__new__(cls,[, …]) 方法"></a>__new__(cls,[, …]) 方法</h3><p>注：python中创建对象时调用的第一个对象其实并不是init，而是__new__方法，new方法是用来创建类的一个新的实例的，一般情况下我们不需要对new方法进行重写，但是有时后我们继承了某些特殊类，需要修改它的默认创建对象的方式时，可以对new方法进行重写。如下所示。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CapStr</span>(<span class="params">str</span>):</span>        <span class="comment"># 继承str类，实现自动转换大写功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, string</span>):</span>    <span class="comment"># cls 是默认参数，就像self一样</span></span><br><span class="line">        string = string.upper()</span><br><span class="line">        <span class="keyword">return</span> str.__new__(cls, string)        <span class="comment"># 返回一个创建好的str实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = CapStr(<span class="string">&#x27;I love you!!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;I LOVE YOU!&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="del-方法"><a href="#del-方法" class="headerlink" title="__del__() 方法"></a>__del__() 方法</h3><p>del 方法和C++中的析构函数类似，就是在程序运行结束后释放资源。一般情况下，python在所有对对象的应用都为空的情况下，会自动调用对象的此函数进行资源释放的。</p>
<h2 id="Python中的所有魔法方法"><a href="#Python中的所有魔法方法" class="headerlink" title="Python中的所有魔法方法"></a>Python中的所有魔法方法</h2><table>
<thead>
<tr>
<th><strong>魔法方法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong>基本的魔法方法</strong></td>
</tr>
<tr>
<td>__new__(cls[, …])</td>
<td>1. __new__ 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 3. __new__决定是否要使用该 __init__方法，因为 __new__可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__没有返回实例对象，则 __init__不会被调用 4. __new__主要是用于继承一个不可变的类型比如一个 tuple 或者 string</td>
</tr>
<tr>
<td>__init__(self[, …])</td>
<td>构造器，当一个实例被创建的时候调用的初始化方法</td>
</tr>
<tr>
<td>__del__(self)</td>
<td>析构器，当一个实例被销毁的时候调用的方法</td>
</tr>
<tr>
<td>__call__(self[, args…])</td>
<td>允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b)</td>
</tr>
<tr>
<td>__len__(self)</td>
<td>定义当被 len() 调用时的行为</td>
</tr>
<tr>
<td>__repr__(self)</td>
<td>定义当被 repr() 调用时的行为，直接使用对象名调用</td>
</tr>
<tr>
<td>__str__(self)</td>
<td>定义当被 str() 调用时的行为</td>
</tr>
<tr>
<td><strong>bytes</strong>(self)</td>
<td>定义当被 bytes() 调用时的行为</td>
</tr>
<tr>
<td><strong>hash</strong>(self)</td>
<td>定义当被 hash() 调用时的行为</td>
</tr>
<tr>
<td><strong>bool</strong>(self)</td>
<td>定义当被 bool() 调用时的行为，应该返回 True 或 False</td>
</tr>
<tr>
<td><strong>format</strong>(self, format_spec)</td>
<td>定义当被 format() 调用时的行为</td>
</tr>
<tr>
<td></td>
<td><strong>有关属性</strong></td>
</tr>
<tr>
<td><strong>getattr</strong>(self, name)</td>
<td>定义当用户试图获取一个不存在的属性时的行为</td>
</tr>
<tr>
<td><strong>getattribute</strong>(self, name)</td>
<td>定义当该类的属性被访问时的行为</td>
</tr>
<tr>
<td><strong>setattr</strong>(self, name, value)</td>
<td>定义当一个属性被设置时的行为</td>
</tr>
<tr>
<td><strong>delattr</strong>(self, name)</td>
<td>定义当一个属性被删除时的行为</td>
</tr>
<tr>
<td><strong>dir</strong>(self)</td>
<td>定义当 dir() 被调用时的行为</td>
</tr>
<tr>
<td><strong>get</strong>(self, instance, owner)</td>
<td>定义当描述符的值被取得时的行为</td>
</tr>
<tr>
<td><strong>set</strong>(self, instance, value)</td>
<td>定义当描述符的值被改变时的行为</td>
</tr>
<tr>
<td><strong>delete</strong>(self, instance)</td>
<td>定义当描述符的值被删除时的行为</td>
</tr>
<tr>
<td></td>
<td><strong>比较操作符</strong></td>
</tr>
<tr>
<td><strong>lt</strong>(self, other)</td>
<td>定义小于号的行为：x &lt; y 调用 x.<strong>lt</strong>(y)</td>
</tr>
<tr>
<td><strong>le</strong>(self, other)</td>
<td>定义小于等于号的行为：x &lt;= y 调用 x.<strong>le</strong>(y)</td>
</tr>
<tr>
<td><strong>eq</strong>(self, other)</td>
<td>定义等于号的行为：x == y 调用 x.<strong>eq</strong>(y)</td>
</tr>
<tr>
<td><strong>ne</strong>(self, other)</td>
<td>定义不等号的行为：x != y 调用 x.<strong>ne</strong>(y)</td>
</tr>
<tr>
<td><strong>gt</strong>(self, other)</td>
<td>定义大于号的行为：x &gt; y 调用 x.<strong>gt</strong>(y)</td>
</tr>
<tr>
<td><strong>ge</strong>(self, other)</td>
<td>定义大于等于号的行为：x &gt;= y 调用 x.<strong>ge</strong>(y)</td>
</tr>
<tr>
<td></td>
<td><strong>算数运算符</strong></td>
</tr>
<tr>
<td><strong>add</strong>(self, other)</td>
<td>定义加法的行为：+</td>
</tr>
<tr>
<td><strong>sub</strong>(self, other)</td>
<td>定义减法的行为：-</td>
</tr>
<tr>
<td><strong>mul</strong>(self, other)</td>
<td>定义乘法的行为：*</td>
</tr>
<tr>
<td><strong>truediv</strong>(self, other)</td>
<td>定义真除法的行为：/</td>
</tr>
<tr>
<td><strong>floordiv</strong>(self, other)</td>
<td>定义整数除法的行为：//</td>
</tr>
<tr>
<td><strong>mod</strong>(self, other)</td>
<td>定义取模算法的行为：%</td>
</tr>
<tr>
<td><strong>divmod</strong>(self, other)</td>
<td>定义当被 divmod() 调用时的行为</td>
</tr>
<tr>
<td><strong>pow</strong>(self, other[, modulo])</td>
<td>定义当被 power() 调用或 ** 运算时的行为</td>
</tr>
<tr>
<td><strong>lshift</strong>(self, other)</td>
<td>定义按位左移位的行为：&lt;&lt;</td>
</tr>
<tr>
<td><strong>rshift</strong>(self, other)</td>
<td>定义按位右移位的行为：&gt;&gt;</td>
</tr>
<tr>
<td><strong>and</strong>(self, other)</td>
<td>定义按位与操作的行为：&amp;</td>
</tr>
<tr>
<td><strong>xor</strong>(self, other)</td>
<td>定义按位异或操作的行为：^</td>
</tr>
<tr>
<td><strong>or</strong>(self, other)</td>
<td>定义按位或操作的行为：|</td>
</tr>
<tr>
<td></td>
<td><strong>反运算</strong></td>
</tr>
<tr>
<td><strong>radd</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rsub</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rmul</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rtruediv</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rfloordiv</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rmod</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rdivmod</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rpow</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rlshift</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rrshift</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rand</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>rxor</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td><strong>ror</strong>(self, other)</td>
<td>（与上方相同，当左操作数不支持相应的操作时被调用）</td>
</tr>
<tr>
<td></td>
<td><strong>增量赋值运算</strong></td>
</tr>
<tr>
<td><strong>iadd</strong>(self, other)</td>
<td>定义赋值加法的行为：+=</td>
</tr>
<tr>
<td><strong>isub</strong>(self, other)</td>
<td>定义赋值减法的行为：-=</td>
</tr>
<tr>
<td><strong>imul</strong>(self, other)</td>
<td>定义赋值乘法的行为：*=</td>
</tr>
<tr>
<td><strong>itruediv</strong>(self, other)</td>
<td>定义赋值真除法的行为：/=</td>
</tr>
<tr>
<td><strong>ifloordiv</strong>(self, other)</td>
<td>定义赋值整数除法的行为：//=</td>
</tr>
<tr>
<td><strong>imod</strong>(self, other)</td>
<td>定义赋值取模算法的行为：%=</td>
</tr>
<tr>
<td><strong>ipow</strong>(self, other[, modulo])</td>
<td>定义赋值幂运算的行为：**=</td>
</tr>
<tr>
<td><strong>ilshift</strong>(self, other)</td>
<td>定义赋值按位左移位的行为：&lt;&lt;=</td>
</tr>
<tr>
<td><strong>irshift</strong>(self, other)</td>
<td>定义赋值按位右移位的行为：&gt;&gt;=</td>
</tr>
<tr>
<td><strong>iand</strong>(self, other)</td>
<td>定义赋值按位与操作的行为：&amp;=</td>
</tr>
<tr>
<td><strong>ixor</strong>(self, other)</td>
<td>定义赋值按位异或操作的行为：^=</td>
</tr>
<tr>
<td><strong>ior</strong>(self, other)</td>
<td>定义赋值按位或操作的行为：|=</td>
</tr>
<tr>
<td></td>
<td><strong>一元操作符</strong></td>
</tr>
<tr>
<td><strong>pos</strong>(self)</td>
<td>定义正号的行为：+x</td>
</tr>
<tr>
<td><strong>neg</strong>(self)</td>
<td>定义负号的行为：-x</td>
</tr>
<tr>
<td><strong>abs</strong>(self)</td>
<td>定义当被 abs() 调用时的行为</td>
</tr>
<tr>
<td><strong>invert</strong>(self)</td>
<td>定义按位求反的行为：~x</td>
</tr>
<tr>
<td></td>
<td><strong>类型转换</strong></td>
</tr>
<tr>
<td><strong>complex</strong>(self)</td>
<td>定义当被 complex() 调用时的行为（需要返回恰当的值）</td>
</tr>
<tr>
<td><strong>int</strong>(self)</td>
<td>定义当被 int() 调用时的行为（需要返回恰当的值）</td>
</tr>
<tr>
<td><strong>float</strong>(self)</td>
<td>定义当被 float() 调用时的行为（需要返回恰当的值）</td>
</tr>
<tr>
<td><strong>round</strong>(self[, n])</td>
<td>定义当被 round() 调用时的行为（需要返回恰当的值）</td>
</tr>
<tr>
<td><strong>index</strong>(self)</td>
<td>1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 <strong>index</strong> 3. 如果 <strong>index</strong> 被定义，则 <strong>int</strong> 也需要被定义，且返回相同的值</td>
</tr>
<tr>
<td></td>
<td><strong>上下文管理（with 语句）</strong></td>
</tr>
<tr>
<td><strong>enter</strong>(self)</td>
<td>1. 定义当使用 with 语句时的初始化行为 2. <strong>enter</strong> 的返回值被 with 语句的目标或者 as 后的名字绑定</td>
</tr>
<tr>
<td><strong>exit</strong>(self, exc_type, exc_value, traceback)</td>
<td>1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作</td>
</tr>
<tr>
<td></td>
<td><strong>容器类型</strong></td>
</tr>
<tr>
<td><strong>len</strong>(self)</td>
<td>定义当被 len() 调用时的行为（返回容器中元素的个数）</td>
</tr>
<tr>
<td><strong>getitem</strong>(self, key)</td>
<td>定义获取容器中指定元素的行为，相当于 self[key]</td>
</tr>
<tr>
<td>__setitem__(self, key, value)</td>
<td>定义设置容器中指定元素的行为，相当于 self[key] = value</td>
</tr>
<tr>
<td>__delitem__(self, key)</td>
<td>定义删除容器中指定元素的行为，相当于 del self[key]</td>
</tr>
<tr>
<td><strong>iter</strong>(self)</td>
<td>定义当迭代容器中的元素的行为</td>
</tr>
<tr>
<td><strong>reversed</strong>(self)</td>
<td>定义当被 reversed() 调用时的行为</td>
</tr>
<tr>
<td><strong>contains</strong>(self, item)</td>
<td>定义当使用成员测试运算符（in 或 not in）时的行为</td>
</tr>
</tbody></table>
<h2 id="简单定制"><a href="#简单定制" class="headerlink" title="简单定制"></a>简单定制</h2><ul>
<li>基本要求<ul>
<li>定制一个计时器类</li>
<li>start 和 stop方法代表启动计时和停止计时</li>
<li>假设计时器对象t1，print(t1) 和直接调用t1均显示结果</li>
<li>当计时器未启动或已经停止计时，调用stop方法会给予温馨的提示</li>
<li>两个计时器对象可以进行相加：t1 + t2</li>
<li>只能使用有限资源完成</li>
</ul>
</li>
</ul>
<h2 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h2><ul>
<li><p>__getattr__(self, name) —– 定义当前用户试图获取一个不存在的属性时的行为。</p>
</li>
<li><p>__getattribute__(self, name)  —– 定义当该类的属性被访问时的行为</p>
</li>
<li><p>__setattr__(self, name, value) —– 定义当一个属性被设置时的行为</p>
</li>
<li><p>__delattr__(self, name) —- 定义当一个属性被删除时的行为的撒  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, name</span>):</span>    <span class="comment"># 访问属性时会首先进入</span></span><br><span class="line">        print(<span class="string">&#x27;getattribute&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__getattribute__(name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,name</span>):</span>        <span class="comment"># 访问的属性不存在的时候进入</span></span><br><span class="line">        print(<span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self,name,value</span>):</span>    <span class="comment"># 设置属性的值的时候进入</span></span><br><span class="line">        print(<span class="string">&#x27;setattr&#x27;</span>)</span><br><span class="line">        super().__setattr__(name,value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self,name</span>):</span>        <span class="comment"># 删除属性的值的时候进入</span></span><br><span class="line">        print(<span class="string">&#x27;delattr&#x27;</span>)</span><br><span class="line">        super().__delattr__(name)</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x</span><br><span class="line">getattribute</span><br><span class="line">getattr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x = <span class="number">1</span></span><br><span class="line">setattr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x</span><br><span class="line">getattribute</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c.x</span><br><span class="line">delattr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x</span><br><span class="line">getattribute</span><br><span class="line">getattr</span><br></pre></td></tr></table></figure>

<h3 id="注意死循环陷阱"><a href="#注意死循环陷阱" class="headerlink" title="注意死循环陷阱"></a>注意死循环陷阱</h3><p><strong>练习要求：</strong></p>
<ul>
<li>写一个矩形类，默认有宽和高两个属性</li>
<li>如果为一个叫square的属性赋值，那么说明这是一个正方形，值就是正方形的边长，此时宽和高都应该等于边长。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,width = <span class="number">0</span>, height =<span class="number">0</span></span>):</span>  <span class="comment">#初始化过程</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;square&#x27;</span>:</span><br><span class="line">            print(<span class="string">&#x27;设置矩形为正方形&#x27;</span>)</span><br><span class="line">            self.width = value</span><br><span class="line">            self.height = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#self.name = value        #这种方式会造成死循环，因为初始化的过程会调用此函数</span></span><br><span class="line">            super().__setattr__(name, value)</span><br><span class="line">            self.__dict__[name] = value <span class="comment">#这种方式也是可以的，因为类中的变量和值就是以字典方式存放的。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getArea</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.width * self.height</span><br></pre></td></tr></table></figure>

<h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><ul>
<li><p>描述符就是将某种<strong>特殊类型</strong>的类的实例指派给另一个类的属性。（特殊类型指的是至少实现以下三个魔术方法中的某一个，或者全部）</p>
<ul>
<li><p>__get__(self, instance, owner)</p>
<p>用于访问属性，它返回属性的值  </p>
</li>
<li><p>__set__(self, instance, value)</p>
</li>
</ul>
<p>​      将在属性分配操作中调用，不返回任何内容</p>
<ul>
<li>__delete__(self, instance)</li>
</ul>
<p>​      控制删除操作，不返回任何内容</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDecriptor</span>:</span>   <span class="comment"># 此为特殊类型的类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        print(<span class="string">&quot;getting...&quot;</span>,self, instance, owner)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        print(<span class="string">&quot;setting...&quot;</span>,self,instance, value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        print(<span class="string">&quot;deleting...&quot;</span>,instance)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>        <span class="comment"># 另一个类</span></span><br><span class="line">    x = MyDecriptor()    <span class="comment"># 将特殊类型的类赋值给测试类的一个属性x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.x   <span class="comment"># 访问属性x时会调用到特殊类中的get方法</span></span><br><span class="line">getting... &lt;__main__.MyDecriptor object at <span class="number">0x000001F5C3C5A190</span>&gt; &lt;__main__.Test object at <span class="number">0x000001F5C3C5A910</span>&gt; &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Test</span>&#x27;&gt;</span></span><br><span class="line">&gt;&gt;&gt; test.x = &quot;大宝&quot;    # 设置属性x时会调用到特殊类中的set方法</span><br><span class="line">setting... &lt;__main__.MyDecriptor object at <span class="number">0x000001F5C3C5A190</span>&gt; &lt;__main__.Test object at <span class="number">0x000001F5C3C5A910</span>&gt; 大宝</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> test.x        <span class="comment"># 删除属性x时会调用到特殊类中的delete方法</span></span><br><span class="line">deleting... &lt;__main__.Test object at <span class="number">0x000001F5C3C5A910</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义自己的property类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProperty</span>:</span>    <span class="comment"># 实现了特殊方法的类，即描述符类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fget=None, fset=None, fdel=None</span>):</span></span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.fget(instance)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        self.fset(instance, value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        self.fdel(instance)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span>    <span class="comment"># 测试类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setX</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._x = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delX</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line">    x = MyProperty(getX, setX, delX)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x = <span class="string">&#x27;大宝&#x27;</span>    <span class="comment">#可以正常赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.x        <span class="comment"># 可以正常读取</span></span><br><span class="line"><span class="string">&#x27;大宝&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c._x    <span class="comment"># 和_x的值一致</span></span><br><span class="line"><span class="string">&#x27;大宝&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c.x  <span class="comment"># 删除属性</span></span><br></pre></td></tr></table></figure>

<p><strong>练习：</strong></p>
<ul>
<li>先定义一个温度类，然后定义两个描述符类用于描述摄氏度和华氏度两个属性。</li>
<li>要求两个属性会自动进行转换，也就是说你可以给摄氏度这个属性赋值，然后打印的华氏度属性是自动转换后的结果。</li>
<li>华氏度 = 摄氏度 * 1.8 + 32</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的代码，直接调用了内置的property函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._celsius = <span class="number">0</span>       <span class="comment">#摄氏度</span></span><br><span class="line">        self._fahrenheit = <span class="number">0</span>     <span class="comment">#华氏度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setCelsius</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._celsius = value</span><br><span class="line">        self._fahrenheit = value * <span class="number">1.8</span> + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCelsius</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._celsius</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setFahrenheit</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._ahrenheit = value</span><br><span class="line">        self._celsius = (value <span class="number">-32</span>) / <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFahrenheit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._fahrenheit</span><br><span class="line"></span><br><span class="line">    celsius = property(getCelsius, setCelsius)</span><br><span class="line">    fahrenheit = property(getFahrenheit, setFahrenheit)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Temperature()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.celsius = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.ahrenheit</span><br><span class="line"><span class="number">68.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fahrenheit = <span class="number">98</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.celsius</span><br><span class="line"><span class="number">36.666666666666664</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 老师的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Celsius</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value = <span class="number">26.0</span></span>):</span></span><br><span class="line">        self.value = float(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance, owner</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance, value</span>):</span></span><br><span class="line">        self.value = float(value)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fahrenheit</span>:</span>   <span class="comment"># 必须得知道华氏度的变量名，即cel</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        instance.cel = (float(value) - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="keyword">return</span> instance.cel * <span class="number">1.8</span> + <span class="number">32</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span>:</span></span><br><span class="line">    cel = Celsius()        <span class="comment"># 直接调用Celsius描述符类</span></span><br><span class="line">    fah = Fahrenheit()    <span class="comment"># 直接调用Fahrenheit描述符类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.cel</span><br><span class="line"><span class="number">26.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fah</span><br><span class="line"><span class="number">78.80000000000001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.cel = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fah</span><br><span class="line"><span class="number">104.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.fah = <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.cel</span><br><span class="line"><span class="number">26.666666666666664</span></span><br></pre></td></tr></table></figure>

<h2 id="定制容器"><a href="#定制容器" class="headerlink" title="定制容器"></a>定制容器</h2><p>定制容器就是利用一些容器类型的魔法方法实现我们自己定义的容器的功能。</p>
<h3 id="协议是什么"><a href="#协议是什么" class="headerlink" title="协议是什么"></a>协议是什么</h3><p><strong>协议(Protocols)：</strong>与其它编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在Python中的协议就没有这些规定了，它更像是一种指南。</p>
<h3 id="容器类型的协议"><a href="#容器类型的协议" class="headerlink" title="容器类型的协议"></a>容器类型的协议</h3><ul>
<li>如果说你希望定制的容器是不可变的话，你只需要定义__len__() 和 __getitem__()方法。</li>
<li>如果你希望定制的容器是可变的话，除了__len__() 和 __getitem__()方法，你还需要定义__setitem__() 和 __delitem__()两个方法。</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li>编写一个不可变的自定义列表，要求记录列表中每个元素被访问的次数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.values = [x <span class="keyword">for</span> x <span class="keyword">in</span> args]   <span class="comment"># 序列迭代</span></span><br><span class="line">        self.count = &#123;&#125;.fromkeys(self.values, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> len(self.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        self.count[self.values[index]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.values[index]</span><br></pre></td></tr></table></figure>

<ul>
<li>可变的列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.values = [x <span class="keyword">for</span> x <span class="keyword">in</span> args]   <span class="comment"># 序列迭代</span></span><br><span class="line">        self.count = &#123;&#125;.fromkeys(self.values, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> len(self.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        self.count[self.values[index]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.values[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.count.pop(self.values[key])</span><br><span class="line">        self.count[value]=<span class="number">0</span></span><br><span class="line">        self.values[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        self.values.remove(self.values[key])</span><br><span class="line">        self.count.pop(self.values[key])</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Python中的for循环之类的都是调用迭代器，它的实现原理如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&#x27;I love you&#x27;</span></span><br><span class="line">it = iter(string)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        each = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(each)</span><br><span class="line">I</span><br><span class="line"> </span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">v</span><br><span class="line">e</span><br><span class="line"> </span><br><span class="line">y</span><br><span class="line">o</span><br><span class="line">u</span><br></pre></td></tr></table></figure>

<h3 id="迭代器中的魔法方法"><a href="#迭代器中的魔法方法" class="headerlink" title="迭代器中的魔法方法"></a>迭代器中的魔法方法</h3><ul>
<li><p>iter()</p>
<p>__iter__()</p>
</li>
<li><p>next()</p>
<p>__next__()</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n = <span class="number">10</span></span>):</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">if</span> self.a &gt; self.n:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> self.a  </span><br></pre></td></tr></table></figure>

<h2 id="生成器-yield"><a href="#生成器-yield" class="headerlink" title="生成器 (yield)"></a>生成器 (yield)</h2><p>Python 生成器是模仿协同程序的概念打造的，所谓的协同程序就是可以运行的独立函数调用，函数可以暂停或者挂起，并在需要的时候从程序离开的地方继续或者重新开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibs</span>():</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> fibs():</span><br><span class="line">    <span class="keyword">if</span> each &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(each, end=<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span>  <span class="number">55</span>  <span class="number">89</span></span><br></pre></td></tr></table></figure>

<h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>自动化生成列表的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 100以内能被2整除，但是不能被3整除的数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>) <span class="keyword">if</span> <span class="keyword">not</span> (i % <span class="number">2</span>) <span class="keyword">and</span> (i % <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">50</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">58</span>, <span class="number">62</span>, <span class="number">64</span>, <span class="number">68</span>, <span class="number">70</span>, <span class="number">74</span>, <span class="number">76</span>, <span class="number">80</span>, <span class="number">82</span>, <span class="number">86</span>, <span class="number">88</span>, <span class="number">92</span>, <span class="number">94</span>, <span class="number">98</span>]</span><br></pre></td></tr></table></figure>

<h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><p>自动化生成字典的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断10以内可以被2整除的数</span></span><br><span class="line">d = &gt;&gt;&gt; d = &#123;i:i%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;  <span class="comment"># 注意冒号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">0</span>: <span class="literal">True</span>, <span class="number">1</span>: <span class="literal">False</span>, <span class="number">2</span>: <span class="literal">True</span>, <span class="number">3</span>: <span class="literal">False</span>, <span class="number">4</span>: <span class="literal">True</span>, <span class="number">5</span>: <span class="literal">False</span>, <span class="number">6</span>: <span class="literal">True</span>, <span class="number">7</span>: <span class="literal">False</span>, <span class="number">8</span>: <span class="literal">True</span>, <span class="number">9</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><p>自动化生成集合的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从一个列表中生成一个集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器推导式"><a href="#迭代器推导式" class="headerlink" title="迭代器推导式"></a>迭代器推导式</h3><p>自动生成一个迭代器。迭代器推导式可以直接作为参数传给函数，且不用加括号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000029DC1633F20</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(e)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(e)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> each <span class="keyword">in</span> e:</span><br><span class="line">    print(each, end=<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="comment">#因为我之前调用了两次next，所以迭代器指向2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代器推导式做参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">2</span>)</span><br><span class="line"><span class="number">2500</span></span><br></pre></td></tr></table></figure>

<p><strong>注：字符串是没有推导式的，因为所有被引号包含的关键字都会被当作字符处理的。而元组也是没有推导式的，元组的推导式会被当作迭代器来使用，并不会生成一个新的元组。</strong></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python 语法学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>魔法方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习之路00</title>
    <url>/archives/37845.html</url>
    <content><![CDATA[<h2 id="Excel的知识体系"><a href="#Excel的知识体系" class="headerlink" title="Excel的知识体系"></a>Excel的知识体系</h2><p>用excel处理数据的基本流程如下：</p>
<ul>
<li>数据导入</li>
<li>规范规则</li>
<li>函数运算</li>
<li>图表制作</li>
<li>数据分析</li>
<li>图表导出</li>
</ul>
<a id="more"></a>

<h2 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h2><ol>
<li>不用键盘，批量导入数据的方法</li>
<li>数据的快速录入及录入规范</li>
<li>函数公式的使用</li>
<li>数据突出的方法</li>
<li>数据透视表的制作</li>
<li>数据图表的制作</li>
<li>数据输出的方法</li>
<li>实战案例综合运用</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习之路01</title>
    <url>/archives/21268.html</url>
    <content><![CDATA[<h2 id="Excel数据导入"><a href="#Excel数据导入" class="headerlink" title="Excel数据导入"></a>Excel数据导入</h2><h3 id="从网页导入数据"><a href="#从网页导入数据" class="headerlink" title="从网页导入数据"></a>从网页导入数据</h3><p>有时候我们需要从网上获取一些数据进行分析，有时复制粘贴可能不是最好的方式，这时候我们可以先试试excel内置的从网页导入数据功能。</p>
<p><code>数据--&gt;自网站</code></p>
<p>例如：我们想对中国<a href="http://quotes.money.163.com/0600050.html">中国联通的股票行情</a> 做一些分析，我们可以按照上述选项，输入对应的网址连接，如下图所示：</p>
<a id="more"></a>

<p><img src="https://i.imgur.com/pZDY73b.png" alt="从网站导入数据"></p>
<p>此时，网站中所有数据都会以列表的形式加载出来，我们可以选择查看，然后导入我们需要的数据。列表显示的样子如下图所示：</p>
<p><img src="https://i.imgur.com/uJvvixb.png" alt="从网站获取的数据"></p>
<h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>对于类似调查问卷的数据，可以使用<strong>简道云</strong>来收集，它可以很方便的设计表单，方便之后的数据收集。同时简道云上有提供各种现成的表单，我们只需要稍加改动，就可以为我们所用。这部分内容可以对数据收集有用，现在主要是学习数据处理技巧，所以这部分内容暂时略过，之后有需要再来完善补充吧。</p>
<h2 id="数据录入规范"><a href="#数据录入规范" class="headerlink" title="数据录入规范"></a>数据录入规范</h2><h3 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h3><p>Excel中系统默认的日期起始为1900/1/1，储存为1。之后所有的日期都是在此基础上进行相加得到的，比如2018/10/1在系统中实际存储的为43374。在excel中被系统认可的日期格式最终都可以转化为一个数字。被认可的格式有：</p>
<ul>
<li>2020/8/25</li>
<li>2020-8-25</li>
<li>2020年8月25日</li>
<li>等等。可以使用<code>Ctrl + 1</code>在设置单元格格式中的日期选项中查看</li>
</ul>
<p>常见的系统认可的时间格式有：</p>
<ul>
<li>12:00</li>
<li>12 PM (注：必须加空格)</li>
<li>12时00分00秒</li>
</ul>
<h3 id="数字和文本格式的差异"><a href="#数字和文本格式的差异" class="headerlink" title="数字和文本格式的差异"></a>数字和文本格式的差异</h3><ul>
<li>文本格式默认是左对齐的，数字格式默认是右对齐的。</li>
<li>本文数据是稳定的，数字格式更加多变，在超出11位后会以科学计数法显示。</li>
<li>文本格式不可以进行运算，数字格式的可以。</li>
</ul>
<h2 id="数据处理的技巧及注意事项"><a href="#数据处理的技巧及注意事项" class="headerlink" title="数据处理的技巧及注意事项"></a>数据处理的技巧及注意事项</h2><p>用excel处理数据时，需要有个前端和后端的概念。前端负责数据存储、加工数据、分析计算。后端用来展示、传递信息。说简单点就是不要在一张表中既包含数据处理，又用来展示数据，这样会显得杂乱无章，又会相互影响。</p>
<h3 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h3><p>为了实现前后端分离的功能，我们可以使用<strong>数据透视表</strong>的功能：<code>选择数据区域--&gt;插入--&gt;数据透视表</code>。注意在使用数据透视表时，单元格的格式必须为通用格式。以下为使用数据透视表求得的年龄的平均值。使用数据透视表对数据进行的所有操作都不会影响到原始数据的数据安全性。</p>
<p><img src="https://i.imgur.com/x9SbAek.png" alt="数据透视表求年龄平均值"></p>
<h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>有时在数据录入的过程中，经常会犯一些合并单元格的错误，我们可能会为了美观，把一些相同单元格的数据进行合并，如下图所示。</p>
<p><img src="https://i.imgur.com/B7qgNEf.png" alt="原始数据"></p>
<p>虽然在观感上好像是清楚了些，但是后期是非常不方便我们进行数据处理的。我们可以使用下述方法将其恢复：<code>选中所有合并的单元格--&gt;合并后居中--&gt;Ctrl+G--&gt;定位条件--&gt;空值</code>，此时excel会自动帮我们选择好需要填充的值，此时我们值需要输入<code>= + 上个单元格的值</code>，可以通过点击上个单元格获取其值。最后再<code>Ctrl + 回车</code>就可以填充好空白的单元格。填充好后，选择填充的单元格，我们发现填充的单元格格式其实是引用上个单元格的，如下图所示。</p>
<p><img src="https://i.imgur.com/vhZCM49.png" alt="填充后的单元格格式"></p>
<p>为了我们数据的稳定性，此时我们可以选中这些数据，复制，然后选择粘贴为值，此时我们就可以得到稳定的处理后的数据了。</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>序号是保证每条数据唯一性的方式，虽然没有序号也不影响我们数据透视表的制作，但是有了序号以后可以防止我们调用数据时出错。</p>
<h3 id="乱加表头"><a href="#乱加表头" class="headerlink" title="乱加表头"></a>乱加表头</h3><p>在数据源的地方不要添加什么斜线表头之类的东西，这样只会给后面的数据处理造成困难。</p>
<h3 id="乱加统计"><a href="#乱加统计" class="headerlink" title="乱加统计"></a>乱加统计</h3><p>在数据录入的过程不要添加任何的统计操作，如合计等。数据录入要尽量保证数据的准确性，合集之类的分析操作就放到数据透视表中即可。</p>
<h3 id="不符合数据透视表规范"><a href="#不符合数据透视表规范" class="headerlink" title="不符合数据透视表规范"></a>不符合数据透视表规范</h3><p>数据透视表的使用需要遵循一定的规范，因此我们在数据录入时也需要遵循一定规范，如下图所示，我们在季度评分录入的时候，需要录入三个季度，此时我们的录入方式应该是将一条数据拆分根据季度和得分的不同拆分为三份。而不是将三个季度分开，增加三列。</p>
<p><img src="https://i.imgur.com/Hp8uBnY.png" alt="不规范的数据录入"></p>
<p>虽然上述方式也能实现不同季度的评分统计，但是我们数据透视表的使用规范应该按照下列方式进行录入。</p>
<p><img src="https://i.imgur.com/GSnKJzP.png" alt="规范的数据录入方式"></p>
<h3 id="该有0就有0"><a href="#该有0就有0" class="headerlink" title="该有0就有0"></a>该有0就有0</h3><p>有时后我们遇到的数据可能为零，此时需录入0，不能空着。0被认为是有效数据，而空值则会被认为是无效数据，无效数据在计算平均值时是不会被记为分母的。</p>
<h3 id="故意空行"><a href="#故意空行" class="headerlink" title="故意空行"></a>故意空行</h3><p>在数据录入的时候不要有空行或者空列，，否则系统在计算是会将其作为两个表来处理。如果想删除空行，只需要选中空行的单元格，然后<code>Ctrl + G --&gt; 选择空值</code>此时excel会自动帮我们选中空行，此时我们只需要在选中的区域点击鼠标右键，选择<code>删除--&gt;整行</code>就好。</p>
<h3 id="数字文本化"><a href="#数字文本化" class="headerlink" title="数字文本化"></a>数字文本化</h3><p>在我们录入不是用作计算的数字时，我们最好在录入数据之前就将单元格格式设置为文本格式，防止后续录入的数据出现问题。</p>
<h3 id="单元格非原子化"><a href="#单元格非原子化" class="headerlink" title="单元格非原子化"></a>单元格非原子化</h3><p>在excel中一个单元格就包含一条信息，不要在一个单元格中包含多条信息，比如将省份名和市名放在一起。如果我们遇到数据在一个单元格的情况，我们可以<code>选中需要分割的数据--&gt;数据--&gt;分裂</code>然后根据自己的需求进行数据的分割。</p>
<h3 id="数据录入不统一"><a href="#数据录入不统一" class="headerlink" title="数据录入不统一"></a>数据录入不统一</h3><p>我们在录入数据时要保证同样含义的数据名是统一的，比如表达性别的用男女就用男女，不要一会男女，一会man\woman的，因为对于数据来说，它们表达的含义是不同的。</p>
<p>为了防止数据录入的不规范，可以使用<code>数据--&gt;数据验证</code>来设置可选项，从而限定数据的录入值。已经录入的错误值可以使用查找替换的方式解决。</p>
<h3 id="表格通用格式的规范"><a href="#表格通用格式的规范" class="headerlink" title="表格通用格式的规范"></a>表格通用格式的规范</h3><ul>
<li>有完整的字段标题</li>
<li>首字段应该为序号</li>
<li>数据和日期要用正确的格式</li>
<li>使用数据的有效性</li>
<li>指表要符合数据透视表的规范</li>
<li>没有空行、空列，空格、统计项</li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel 快速录入和定位的小技巧</title>
    <url>/archives/57650.html</url>
    <content><![CDATA[<h2 id="相似格式如何一秒快速录入"><a href="#相似格式如何一秒快速录入" class="headerlink" title="相似格式如何一秒快速录入"></a>相似格式如何一秒快速录入</h2><p>在数据录入的过程中经常需要录入一些相同的部分，比如同一个省份的开头是相同的，邮箱的后半部分。此时我们可以自定义单元格格式来加速我们数据录入的过程。</p>
<a id="more"></a>

<p><img src="https://i.imgur.com/tQUDhXi.jpg" alt="单元格格式设置"></p>
<h2 id="录入长串数字的方法"><a href="#录入长串数字的方法" class="headerlink" title="录入长串数字的方法"></a>录入长串数字的方法</h2><p>将单元格格式设置为文本格式即可。</p>
<h2 id="如何将手机号码分段显示"><a href="#如何将手机号码分段显示" class="headerlink" title="如何将手机号码分段显示"></a>如何将手机号码分段显示</h2><p>将单元格格式设置为自定义的<code>000-0000-0000</code>手机号码显示时就会按照这个格式分隔开比如132-xxxx-xxxx，如果你不想用-隔开，也可以直接输入空格，就会变成132 xxxx xxxx。</p>
<h2 id="组织-Excel-自动生成超链接"><a href="#组织-Excel-自动生成超链接" class="headerlink" title="组织 Excel 自动生成超链接"></a>组织 Excel 自动生成超链接</h2><p>在excel中输入邮箱和网址时会自动生成超链接，鼠标不小心点到时就会跳转，很烦人。此时也可以通过设置来关闭: <code>文件--&gt;选项--&gt;校对--&gt;自动更正选项--&gt;键入时自动套用格式--&gt;取消勾选Internet 及网路路径替换为超链接</code></p>
<h2 id="下拉菜单输入"><a href="#下拉菜单输入" class="headerlink" title="下拉菜单输入"></a>下拉菜单输入</h2><p>在空白处列表中输入需要的菜单名称，然后再选中需要使用下拉菜单输入的单元格，然后点击<code>数据--&gt;数据验证--&gt;设置</code>将验证条件中的允许设为序列，然后点击来源右边的小箭头，选中刚才输入的单元格即可。</p>
<h2 id="横列转数列"><a href="#横列转数列" class="headerlink" title="横列转数列"></a>横列转数列</h2><p>先选中需要转置的单元格，复制。然后点击鼠标右键，选择<code>选择性粘贴</code>，再弹出的对话框中勾选转置即可。</p>
<h2 id="空白单元格的批量填充"><a href="#空白单元格的批量填充" class="headerlink" title="空白单元格的批量填充"></a>空白单元格的批量填充</h2><p>选中整个表格，在开始菜单中点击定位功能或者<code>Ctrl+G</code>，然后选择定位条件为：空值。然后在第一个表格中输入<code>=</code>然后再点击上一个表格，最后再<code>Ctrl+回车</code>，所有空白的区域都会以表格中的上一个值填充。最后再复制表格内容，粘贴为值。</p>
<h2 id="Alt-向下方向键：显示前面录入过的内容"><a href="#Alt-向下方向键：显示前面录入过的内容" class="headerlink" title="Alt + 向下方向键：显示前面录入过的内容"></a>Alt + 向下方向键：显示前面录入过的内容</h2><h2 id="Excel-中如何快速定位公式"><a href="#Excel-中如何快速定位公式" class="headerlink" title="Excel 中如何快速定位公式"></a>Excel 中如何快速定位公式</h2><p>在表格中如果向查看哪些单元格使用了公式，可以使用定位功能，然后选择条件为公式就可以查到。也可以在<code>开始</code>菜单中的<code>查找和选择</code>下点击<code>公式</code>进行定位。</p>
<h2 id="输入开头为0的文本数据"><a href="#输入开头为0的文本数据" class="headerlink" title="输入开头为0的文本数据"></a>输入开头为0的文本数据</h2><p>可以在数据前输入单引号或者将单元格格式设置为文本格式。</p>
<h2 id="多个0的录入"><a href="#多个0的录入" class="headerlink" title="多个0的录入"></a>多个0的录入</h2><p>在常规单元格中输入<code>1**8</code>会变为100000000，快速在末尾添加8个零。</p>
<h2 id="快速填充"><a href="#快速填充" class="headerlink" title="快速填充"></a>快速填充</h2><p><code>Ctrl + D</code> 向下填充，<code>Ctrl + R</code> 向右填充。</p>
<h2 id="使用-Tab-键进行移动"><a href="#使用-Tab-键进行移动" class="headerlink" title="使用 Tab 键进行移动"></a>使用 Tab 键进行移动</h2><p>使用<code>Tab</code> 键进行移动时，输入完一行数据后，按回车会自动跳转到下一行的起始处，可以加快数据录入的效率。</p>
<h2 id="同组工作表数据录入"><a href="#同组工作表数据录入" class="headerlink" title="同组工作表数据录入"></a>同组工作表数据录入</h2><p>需要在多个单元格中输入相同内容时，可以先按住<code>Ctrl键</code>选中这些单元格，然后输入数据，最后<code>Ctrl+回车</code>，所有单元格就会输入相同的值。</p>
<p>同理，想在不同表中的同一位置输入相同值的时候，可以先按住<code>Ctrl键</code>选中这些表，此时输入内容时，其它表中相同位置也会输入同样内容。</p>
<h2 id="快速删除工作表中空行"><a href="#快速删除工作表中空行" class="headerlink" title="快速删除工作表中空行"></a>快速删除工作表中空行</h2><p>首先按<code>F5</code>或者<code>Ctrl + G</code> 设置定位条件为：<code>空值</code>，然后在<code>开始菜单</code>下的<code>删除</code>中，选择<code>删除工作表行</code>就可以删除空行了。</p>
<h2 id="提取差异单元格，并标注颜色"><a href="#提取差异单元格，并标注颜色" class="headerlink" title="提取差异单元格，并标注颜色"></a>提取差异单元格，并标注颜色</h2><p>选中整个表格，然后点击<code>开始菜单</code>下的<code>条件格式</code>，在<code>突出显示单元格规则</code>下选择<code>重复</code>，此时就会将所有重复值都突出显示出来。</p>
<h2 id="快速提取身份证号码"><a href="#快速提取身份证号码" class="headerlink" title="快速提取身份证号码"></a>快速提取身份证号码</h2><p>如果我们想从身份证号码中，快速提取出出生年月日，我们可以使用这个公式：<code>TEXT(MID(A2,7,8),&quot;0000-00-00&quot;)</code>就可以了。</p>
<h2 id="套用电子表格样式"><a href="#套用电子表格样式" class="headerlink" title="套用电子表格样式"></a>套用电子表格样式</h2><p><strong>套用电子表格样式的好处：</strong></p>
<ul>
<li>便于阅读</li>
<li>可以帮助我们更快速地录入信息</li>
<li>能帮助完善字段标题</li>
<li>方便对数据进行筛选、计算和删除重复项</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>有时太智能了，可能会计算出一些我们不想要的结果，因为转换后计算的公式是自动全表应用的。此时我们使用转换表格设计中转换为区域的功能，转换完之后表格就不会自动计算所有值了。也可以使用清除格式，来清除表格格式。</li>
</ul>
<h3 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h3><ul>
<li>选中整个表格：先选择第一个表格，按住Ctrl+Shift键，再依次按方向右键和下键，即可选中整个表格</li>
<li>套用电子表格样式：Ctrl + L键。</li>
</ul>
<h2 id="实战案例—销售数据表格"><a href="#实战案例—销售数据表格" class="headerlink" title="实战案例—销售数据表格"></a>实战案例—销售数据表格</h2><h3 id="删除空格"><a href="#删除空格" class="headerlink" title="删除空格"></a>删除空格</h3><p>拿到一张数据表的时候，首先要做的就是删除表中的空格，因为空格可能会对之后的数据计算造成影响。删除空格可以使用查找替换的方法。</p>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>查看表格是否包含序列，没有就增加序列。</p>
<h3 id="解决合并单元格的问题"><a href="#解决合并单元格的问题" class="headerlink" title="解决合并单元格的问题"></a>解决合并单元格的问题</h3><p>将合并的单元格进行拆分，并且填充为相同的数据。</p>
<h3 id="单元格包含多个信息"><a href="#单元格包含多个信息" class="headerlink" title="单元格包含多个信息"></a>单元格包含多个信息</h3><p>查看单元格是否包含了格信息，如果是，利用数列的拆分技巧，将单元格内容拆分为多列。</p>
<p>方法：先新在需要分列的数据后建空白列，然后选中分列的数据（不要选到表头），在数据选项卡下选择分列功能，按照需要分列的数据属性进行相应的分列设置。</p>
<h3 id="删除空行"><a href="#删除空行" class="headerlink" title="删除空行"></a>删除空行</h3><p>参考之前介绍的方法，删除空行。</p>
<h3 id="更改时间时期格式"><a href="#更改时间时期格式" class="headerlink" title="更改时间时期格式"></a>更改时间时期格式</h3><p>系统认可的时间日期格式为’ - ‘或者’ / ‘，可以利用查找替换来进行更改。</p>
<h3 id="数值数据被转成了科学计数显示"><a href="#数值数据被转成了科学计数显示" class="headerlink" title="数值数据被转成了科学计数显示"></a>数值数据被转成了科学计数显示</h3><p>这个一旦转换后，是无法挽救的，因此一定要注意在录入之前就将单元格格式设置为文本格式。</p>
<h3 id="用于计算的数据"><a href="#用于计算的数据" class="headerlink" title="用于计算的数据"></a>用于计算的数据</h3><p>用于计算的数据一定得是数值格式，不然会出现公式计算错误。如果非要加一些文本，可以用设置单元格格式的方式增加。</p>
<h3 id="增加表格样式"><a href="#增加表格样式" class="headerlink" title="增加表格样式"></a>增加表格样式</h3><p>在修改完表格的错误之后，可以给表格套用表格样式，使得表格便于阅读。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>数据录入</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习之路-函数</title>
    <url>/archives/13281.html</url>
    <content><![CDATA[<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>函数是我们对原本数据进行计算统计或者用来增加字段的一种表达方式。</p>
<ol>
<li>兼容性函数 — 38</li>
<li>多维数据集函数 — 7</li>
<li>数据库函数 — 12</li>
<li>日期和时间函数  — 22</li>
<li>工程函数 — 41</li>
<li>财务函数 — 53</li>
<li>信息函数 —17</li>
<li>逻辑函数 — 7</li>
<li>查找和引用函数 — 20</li>
<li>数学和三角函数 — 63</li>
<li>统计函数 — 98</li>
<li>文本函数 — 27</li>
</ol>
<a id="more"></a>

<h3 id="Excel-单元格命名"><a href="#Excel-单元格命名" class="headerlink" title="Excel 单元格命名"></a>Excel 单元格命名</h3><p>在我们应用公式的时候，可以对单元格，或者单元格块进行重命名，之后我们在其它页使用公式时就可以通过命名快速选取单元格。</p>
<p><strong>命名时注意：</strong></p>
<ul>
<li>Excel名称不能使用RC</li>
<li>空格会被下划线自动填充</li>
<li>与单元格相同的名称避免使用</li>
<li>符号只能使用”.”或者下划线”_”</li>
</ul>
<p>想要删除命名时，可以通过<code>公式--&gt;名称管理器</code>找到相应的命名删除即可。</p>
<h3 id="单元格引用"><a href="#单元格引用" class="headerlink" title="单元格引用"></a>单元格引用</h3><ul>
<li>绝对引用：行和列都锁定。如：<code>$A$2</code>.</li>
<li>相对引用：行和列只锁定一个。如：<code>列不变：$A2</code>，<code>行不变：A$2</code>.</li>
<li>混合引用：一个锁定行，一个锁定列</li>
</ul>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="Vlookup-函数"><a href="#Vlookup-函数" class="headerlink" title="Vlookup 函数"></a>Vlookup 函数</h3><p>Vlookup函数使用条件：</p>
<ul>
<li>有两张表</li>
<li>两张表要有共通的字段</li>
<li>表一缺失的字段能在表二里面找得到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])</span><br><span class="line">lookup_value:你要查找的值</span><br><span class="line">table_array:你要查找的值在哪个区域（需要用的绝对引用，或者区域命名）</span><br><span class="line">col_index_num:查找的值在区域当中的第几列</span><br><span class="line">range_lookup:模糊查找 or 精确查找：0</span><br></pre></td></tr></table></figure>

<p>此时我们就可以使用表二中表一缺失的字段来填补表一。比如说根据员工的姓名，从其它表中复制一些相应信息时可以使用。</p>
<p><strong>VLOOKUP 多条件查找：</strong></p>
<p><code>=VLOOKUP(E2&amp;F2,IF(&#123;1,0&#125;,A2:A7&amp;B2:B7,C2:C7),2,0)</code> 其中E2和F2是两个查找条件，IF中的这一团东西A2:A7&amp;B2:B7与E2和F2对应，C2：C7表示查找区域。{1,0} 还不知道。</p>
<h3 id="IF-函数"><a href="#IF-函数" class="headerlink" title="IF 函数"></a>IF 函数</h3><p>IF 函数在excel中主要是用于逻辑判断。</p>
<p>IF 函数的基本语法为：<code>IF(判断条件, 如果为真执行, 如果为假执行)</code>，用于判断运算的符号有：<code>=, &gt;, &lt;, &gt;=, &lt;=, &gt;&lt;(不等于)</code>。在使用IF函数时可以进行嵌套使用或者和AND或者OR函数联合使用，从而实现复杂的逻辑判断。</p>
<h3 id="MATCH-和-INDEX-函数"><a href="#MATCH-和-INDEX-函数" class="headerlink" title="MATCH 和 INDEX 函数"></a>MATCH 和 INDEX 函数</h3><p><strong>INDEX与MATCH函数的语法:</strong></p>
<p><code>INDEX (array, row_num, [column_num])</code> — 返回表或区域中的值。引用三个参数分别为数据表区域， 行数， 列数。</p>
<p><code>MATCH (lookup_value, looup_array, [match_type])</code> — 返回指定数值在指定数组区域中的位置。 三个参数分别为查找的值、 查找单元格区域、查找方式。</p>
<p>这两个函数通常是配合使用的，首先使用MATCH函数索引到位置，然后使用INDEX根据索引位置得到索引值。</p>
<h3 id="条件求和"><a href="#条件求和" class="headerlink" title="条件求和"></a>条件求和</h3><p><code>SUMIF(条件区域，指定的求和条件，求和区域)</code></p>
<p>示例：求一班总成绩，公式：<code>=SUMIF(C2:C5,E2,D2:D5)</code> </p>
<p><img src="https://i.imgur.com/DUp9E46.png" alt="SUNMIF 求和"></p>
<h3 id="多条件求和"><a href="#多条件求和" class="headerlink" title="多条件求和"></a>多条件求和</h3><p><code>SUMIFS(求和区域，条件区域1，指定的求和条件1，条件区域2，指定的求和条件2，...)</code> </p>
<p>示例：统计部门及岗位的补助金额之和，公式：<code>=SUMIFS(D2:D9,B2:B9,F2,C2:C9,G2)</code> </p>
<p><img src="https://i.imgur.com/2b156t1.png" alt="SUMIFS 多条件求和"> </p>
<h3 id="条件计数"><a href="#条件计数" class="headerlink" title="条件计数"></a>条件计数</h3><p><code>COUNTIF(条件区域，指定计数条件)</code></p>
<p>示例：统计店铺数量。 公式：<code>=COUNTIF(B2:B12,E2)</code> </p>
<p><img src="https://i.imgur.com/CDzuNKb.png" alt="CONTIF 条件计数"></p>
<h3 id="多条件计数"><a href="#多条件计数" class="headerlink" title="多条件计数"></a>多条件计数</h3><p><code>COUNTIF(条件区域1，指定计数条件1，条件区域2，指定计数条件2,...)</code></p>
<p>使用方法同上，只不过是加入了多个条件。</p>
<h3 id="计算文本算式"><a href="#计算文本算式" class="headerlink" title="计算文本算式"></a>计算文本算式</h3><p>在一些工程类的表格中可能会用到一些文本类型的算式，如何快速计算出结果呢？点击<code>公式--&gt;定义名称</code> 在弹出的对话框中输入<code>公式名称</code>，引用位置处输入<code>EVALUATE(B2)</code> B2为公式所在的单元格，然后在需要引入公式的单元格处输入<code>=公式名称</code> 即可。</p>
<h3 id="合并多个单元格内容"><a href="#合并多个单元格内容" class="headerlink" title="合并多个单元格内容"></a>合并多个单元格内容</h3><p>在需要输入合并单元格内容的单元格内输入<code>单元格1&amp;单元格2&amp;单元格3...</code> 用&amp;连接，就可以将它们合并了。也可以直接输入合并后的结果，按<code>Ctrl + E</code> 就可以把其它所有单元格按照合并后的结果进行填充了。</p>
<h3 id="合并带有格式的单元格内容"><a href="#合并带有格式的单元格内容" class="headerlink" title="合并带有格式的单元格内容"></a>合并带有格式的单元格内容</h3><p>需要合并带有格式的单元格如日期和时间时，可以将带有格式的单元格转换为文本然后再进行合并。比如<code>A2&amp;TEXT(B2,&quot;y年m月d日&quot;)</code> 意思就是将单元格B2的时间按照年月日的方式转换为文本，再和A2单元格进行合并。</p>
<h3 id="REPLACE-函数"><a href="#REPLACE-函数" class="headerlink" title="REPLACE 函数"></a>REPLACE 函数</h3><p>REPLACE函数可以将单元格内的某些字符进行替换，如电话号码中间的4位，身份证中间的某几位。</p>
<p>使用方法：<code>REPLACE(目标单元格, 起始位, 替换几位, &quot;替换内容&quot;)</code> </p>
<h3 id="屏蔽函数公式返回的错误值"><a href="#屏蔽函数公式返回的错误值" class="headerlink" title="屏蔽函数公式返回的错误值"></a>屏蔽函数公式返回的错误值</h3><p>为了避免计算公式计算时返回各种各样的错误值，可以通过<code>IFERROR</code> 函数，设置如果有错误则返回什么值。如：<code>=IFERROR(A2/B2,-1)</code> ，如果A2/B2计算错误，就返回-1.</p>
<h3 id="四舍五入函数"><a href="#四舍五入函数" class="headerlink" title="四舍五入函数"></a>四舍五入函数</h3><p><code>ROUND(值, 保留位数)</code> 函数是用来进行四舍五入的函数，使用起来也非常方便。</p>
<h3 id="取整的间隔小时数"><a href="#取整的间隔小时数" class="headerlink" title="取整的间隔小时数"></a>取整的间隔小时数</h3><p>需要计算时间间隔可以使用<code>TEXT(B2-B1,&quot;[h]小时&quot;)</code> B1和B2是两个系统可以识别的时间，计算后的单位可以位[h]–小时，[m]–分钟，[s]–秒。</p>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><p><code>TODAY()</code> – 显示今天的日期。<code>2020/8/30</code></p>
<p><code>NOW()</code> – 显示今天的日期和时间。 <code>2020/8/30  14:53</code></p>
<p><code>YEAR(&quot;2018/3/21&quot;)</code> – 只显示这个日期的年。 <code>2018</code></p>
<p><code>MONTH(&quot;2018/3/21&quot;)</code> – 3</p>
<p><code>DAY(&quot;2018/3/21&quot;)</code> – 21</p>
<p><code>HOUR(&quot;12:32:09&quot;)</code>  – 12  (0~23)</p>
<p><code>MINUTE(&quot;12:32:09&quot;)</code>  – 32  (0~59)</p>
<p><code>SECOND(&quot;12:32:09&quot;)</code> – 9 (0~59)</p>
<h3 id="计算某个日期是星期几"><a href="#计算某个日期是星期几" class="headerlink" title="计算某个日期是星期几"></a>计算某个日期是星期几</h3><p>使用公式<code>TEXT(WEEKDAY(&quot;2018/6/12&quot;),&quot;aaaa&quot;)</code> 就可以计算出日期“2018/6/12”是星期几了。</p>
<h3 id="根据日期计算年龄"><a href="#根据日期计算年龄" class="headerlink" title="根据日期计算年龄"></a>根据日期计算年龄</h3><p>使用公式：<code>DATEDIF(出生日期, TODAY(), &quot;Y&quot;)</code> 就可以计算出年龄了。</p>
<h3 id="从身份证号码中提取性别"><a href="#从身份证号码中提取性别" class="headerlink" title="从身份证号码中提取性别"></a>从身份证号码中提取性别</h3><p>直接使用公式：<code>IF(MOD(MID(A2,17,1),2)=1,&quot;男&quot;,&quot;女&quot;)</code> 就可以实现。其中A2单元格中是身份证号码，MID()是用来提取第17位数字，MOD()是用来判断该数字是否可以被2整除，IF()是用来做最终的判断的。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>Excel</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习之路之微图表</title>
    <url>/archives/4338.html</url>
    <content><![CDATA[<h2 id="什么是微图表"><a href="#什么是微图表" class="headerlink" title="什么是微图表"></a>什么是微图表</h2><p>微图表简单的说就是在单元格内绘制的图表，用来直观的反应数据的大小，从而实现数据与图表的一体化。示例如下图。</p>
<p><img src="https://i.imgur.com/fnxrIjW.png" alt="微图表示例"></p>
<a id="more"></a>

<h2 id="如何绘制微图表"><a href="#如何绘制微图表" class="headerlink" title="如何绘制微图表"></a>如何绘制微图表</h2><p>下面为一般微图表的绘制过程，我们使用的绘制数据如下，其中数据表列的数据为完成率的复制值。</p>
<img src="https://i.imgur.com/7QZ93nq.png" alt="绘制微图表的数据" style="zoom:80%;" />

<p>选择数据表列的数据，点击<code>开始--&gt;条件格式--&gt;数据条</code> 然后选择一个样式，即可建立一个简单的条形微图表，如下图所示。</p>
<img src="https://i.imgur.com/jUhRgjD.png" alt="条形微图表" style="zoom:80%;" />

<p>通过设置微图表的格式来影藏百分比的数值，<code>开始--&gt;条件格式--&gt;管理规则</code> ，点击<code>编辑规则</code> 弹出如下图所示的对话框：</p>
<p><img src="https://i.imgur.com/jkzbcQ5.png" alt="编辑格式规则"> </p>
<p>勾选<code>仅显示数据条</code> 即可隐藏百分比，最后结果如下图所示：</p>
<img src="https://i.imgur.com/8DtejsQ.png" alt="最终结果" style="zoom:80%;" />

<p>注：有时我们的绘制值可能为负值，在最新版的绘制方式中，可以直接已相反的方向绘制出来。</p>
<p>除此之外我们还可以用条件格式中的<code>新建格式规则</code> 功能，新建饼图等图标。新建格式规则页面如下图所示：</p>
<img src="https://i.imgur.com/plAuulj.png" alt="新建格式规则" style="zoom:80%;" />

<p>选择扇形图，最终我们得到的结果如下图所示：</p>
<img src="https://i.imgur.com/EhESA6f.png" alt="最终结果" style="zoom:80%;" /> 

<h3 id="Sparkline-的使用"><a href="#Sparkline-的使用" class="headerlink" title="Sparkline 的使用"></a>Sparkline 的使用</h3><p>Sparkline是微软开发的用于快速绘制微图表的一个宏文件，使用的时候直接下载下来然后拖入到当前excel窗口就行。它的主要作用就是简化微图表的制作过程，不过最新的excel表格中已经禁用了。个人感觉通过excel自带的微图表功能已经够了。</p>
<p><a href="/download/SparklinesCn-X64.xlam">点击下载64位的Sparkline插件</a> </p>
<p>使用Sparkline插入扇形图，结果如下：</p>
<img src="https://i.imgur.com/BouuTPk.png" alt="Sparkline 插入扇形图示例" style="zoom:80%;" /> 

<h2 id="快速-highlight-重点数据"><a href="#快速-highlight-重点数据" class="headerlink" title="快速 highlight 重点数据"></a>快速 highlight 重点数据</h2><h3 id="标记出某个范围的数据"><a href="#标记出某个范围的数据" class="headerlink" title="标记出某个范围的数据"></a>标记出某个范围的数据</h3><p><strong>圈出数据：</strong></p>
<p>比如标记出数据大小小于某个值的数据，先选中该数据区域，<code>数据--&gt;数据验证--&gt;数据验证</code> 将验证条件设置为<code>允许：小数</code>，数据范围可以根据自己的需求设置。设置好有效的数据后就可以使用<code>数据--&gt;数据验证--&gt;圈释无效数据</code> 将数据不符合刚才所设范围的数据圈出了。 </p>
<p><strong>用颜色块标记：</strong></p>
<p>先选中数据区域，<code>开始--&gt;条件格式--&gt;突出显示单元格的规则</code> 根据需要选择相应规则即可。</p>
<p><strong>设置复杂的标记规则：</strong></p>
<p>有时我们希望对单元格进行计算，计算结果满足一定值时再将其标记出来。此时先选中需要计算的区域，<code>开始--&gt;条件格式--&gt;新建格式规则</code> ，在弹出的对话框中选择规则类型为：使用公式确定要设置格式的单元格。然后设置相应的公式，比如：</p>
<img src="https://i.imgur.com/DanGIoG.png" alt="使用公式确定规则" style="zoom:80%;" />

<p>其中E2和D2是保持列不变。标记为绿色是通过格式中的填充色进行设置的。</p>
<p>如果想清除规则，<code>开始--&gt;条件格式--&gt;清除规则</code> 按需要清除即可。</p>
<h3 id="查找最大值和最小值"><a href="#查找最大值和最小值" class="headerlink" title="查找最大值和最小值"></a>查找最大值和最小值</h3><p>首先选中需要查找的数据列，<code>开始--&gt;条件格式--&gt;新建格式规则</code> ，还是选择使用公式确定要设置格式的单元格，然后录入一个查找最大值的公式：<code>=B2=Max(绝对引用数据列)</code> ,然后设置标记格式即可。</p>
<p>查找最小值和查找最大值类似，只不过使用的是MIN()函数。</p>
<h3 id="查找重复数据"><a href="#查找重复数据" class="headerlink" title="查找重复数据"></a>查找重复数据</h3><p>选择需要查找重复值的数据列，<code>开始--&gt;条件格式--&gt;突出显示单元格的规则</code> ,然后选择重复值，就可以将重复的单元格标记出来了。</p>
<p><strong>删除重复条目：</strong></p>
<p>重复条目应该是每个信息都重复，删除步骤：<code>选中数据表--&gt;数据--&gt;删除重复值</code>,可以根据自己的需求选择重复的字段，一般全选，点击确定即可。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>数据分析</tag>
        <tag>微图表</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习之数据透视表</title>
    <url>/archives/50892.html</url>
    <content><![CDATA[<h2 id="初识数据透视表"><a href="#初识数据透视表" class="headerlink" title="初识数据透视表"></a>初识数据透视表</h2><p>数据透视表在使用的时候非常简单，但是我们得先想清楚一些问题，再开始动手。</p>
<p><strong>罗列什么、汇总什么</strong></p>
<p>把需要罗列的部分放入行区域当中，需要计算的字段放入值区域当中。</p>
<p><strong>他们是怎样的关系，要按照怎样的顺序来排列</strong></p>
<p>如果是上下级关系的，那我们就全部放在行区域内，如果是交叉区域的，就放在列区域内，在同一个区域就要按照顺序来进行摆放</p>
<p><strong>以什么方式来进行汇总？是合计数、求平均、还是计数值？</strong></p>
<p><strong>是否需要分页进行筛选？</strong></p>
<p>使用筛选器。</p>
<a id="more"></a>

<h3 id="插入数据透视表"><a href="#插入数据透视表" class="headerlink" title="插入数据透视表"></a>插入数据透视表</h3><p>随便选中一个数据区域内的单元格，然后点击<code>插入--&gt;数据透视表</code>，默认会新建一个表来显示。新建好的数据透视表内，拖拽就可以生成自己的数据透视表了。比如下面这个数据透视表。</p>
<img src="https://i.imgur.com/9kS1EHP.png" alt="默认生成的数据透视表" style="zoom:80%;" />

<h2 id="数据透视表的美化"><a href="#数据透视表的美化" class="headerlink" title="数据透视表的美化"></a>数据透视表的美化</h2><p>数据透视表的美化在设计菜单栏下完成的，主要可以对以下部分进行设置，从而达到美化的效果。</p>
<ol>
<li>点击分类汇总，选择不显示分类汇总 (分类汇总就是对于每个大的字段的求和，一般情况可以关闭)。</li>
<li>如果不需要表格底部的总计，可以点击总计，选择对行和列禁用来删除。</li>
<li>调整报表布局，系统默认的报表布局都是以压缩的形式显示的。为了方便我们阅读，我们可以选择以表格的方式显示，此时数据透视表的显示方式会更符合我们的阅读习惯。我们也可以在报表布局中选择重复所有项目标签，此时透视表的显示就和我们的表格基本一致了。</li>
<li>空行，一般我们会删除对于的空行，使得表格显示更为紧凑。在空行中选择删除每个项目后的空行即可。</li>
<li>勾选：列标题、镶边行。取消勾选：行标题、镶边列。此时表格的显示既清晰又简单。（列标题指的是表头加深显示，行标题指的是每行的第一个字段加深显示，镶边行会加深显示不同行，镶边列会加深求和项的列。）</li>
<li>数据透视表样式，可以在下拉菜单中选择一个自己喜欢的样式。</li>
<li>表头美化，表头会默认显示：<code>求和项：+ 列名</code> 可以改为<code>列名+空格</code> 因为求和项的列名不能和表格中的列名重复。</li>
</ol>
<p><strong>美化后的最终样子：</strong></p>
<img src="https://i.imgur.com/Xmhkmiu.png" alt="美化后的数据透视表" style="zoom:80%;" />

<p>表格中第一列的减号表示可以收缩的的部分，可以通过<code>分析--&gt; +/-按钮</code> 关掉。</p>
<h2 id="数据透视表的应用案例"><a href="#数据透视表的应用案例" class="headerlink" title="数据透视表的应用案例"></a>数据透视表的应用案例</h2><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>我们使用的原始数据如下图所示：</p>
<img src="https://i.imgur.com/NFVDTWh.png" alt="案例一原始数据" style="zoom:80%;" />

<p>选中表内的任一单元格，在插入菜单栏中插入数据透视表，弹出的对话框会默认选中该表格，直接点击确认就好，在数据透视表字段中拖拽菜单就可以形成如下表格了。</p>
<img src="https://i.imgur.com/VcmPZHK.png" alt="案例一：求各单位的领用数量" style="zoom:80%;" />

<p>数据透视表在改变布局方面有非常明显的优势，我们可以根据自己的需要将统计项的字段拉入到行或者列，比如下图。</p>
<img src="https://i.imgur.com/AADVXpK.png" alt="案例一：统计各科室领用用品的数量" style="zoom:80%;" />

<p>我们也可以统计不同时间内的领用用品的数量，此时就不需要科室这个字段了，直接取消勾选就好。在最新版的excel365中，默认是按照年组合的，如下图所示：</p>
<img src="https://i.imgur.com/4fRQCCK.png" alt="案例一：按年份统计" style="zoom:80%;" />

<p>如果我们想按季度，按月份进行统计，只需要选中年份单元格，点击分析菜单栏中的分组字段，在弹出来的对话框中选中季度和月就好，最后我们就可以得到季度和月份的详细统计。</p>
<img src="https://i.imgur.com/iyAMk73.png" alt="案例一：按年、季度、月份进行统计" style="zoom:80%;" />

<h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>案例二主要演示用数据透视表统计最大值和最小值。我们使用的原始数据如下。</p>
<img src="https://i.imgur.com/vOafRsZ.png" alt="案例二原始数据" style="zoom:80%;" />

<p>首先插入一个数据透视表，然后将学科拖到行区域，将成绩拖两次到值区域，单击值区域中的成绩，选择 值字段设置 在计算类型中选择最大值，单击另一个成绩，选择最小值。此时就统计出了各科成绩中的最大值和最小值。</p>
<h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h3><p>这个案例是统计每个业务单元，不重复公司的个数。我们使用的数据部分显示如下。</p>
<img src="https://i.imgur.com/iFbTrwQ.png" alt="案例三原始数据" style="zoom:80%;" />

<p>首先还是用这块区域的数据，建立一个数据透视表。但是这次在建立数据透视表的时候需要勾选<code>将此数据添加到数据模型</code> ，此时才统计的便是不重复的项，不然只会统计个数。然后将业务单元拖到行区域，公司拖到值区域。此时单击值区域中的公司，点击 值字段设置，在计算类型中选择 非重复计数。注：如果没有勾选<code>将此数据添加到数据模型</code> 是找不到 非重复计数 这个选项的。</p>
<h2 id="切片器"><a href="#切片器" class="headerlink" title="切片器"></a>切片器</h2><p>切片器是office2010以上的版本才有的功能，切片器可以非常方便的进行数据过滤，并且可以和图片进行联动，从而实现不同数据的快速查看。</p>
<h3 id="切片器案例一"><a href="#切片器案例一" class="headerlink" title="切片器案例一"></a>切片器案例一</h3><p>这个案例包含了切片器的创建，图标的创建以及切片器和图标的联动。我们使用的数据如下。</p>
<img src="https://i.imgur.com/q2HKZ06.png" alt="切片器案例一原始数据" style="zoom:80%;" />

<p>第一步，还是插入数据透视表，将月份拖入列区域，年份和公司分别拖入到行区域，销售额拖入到值区域。我们得到下图所示透视表。</p>
<img src="https://i.imgur.com/HUtmJuB.png" alt="切片器案例一数据透视表" style="zoom:80%;" />

<p>第二步，点击选中数据透视表的任何区域，在分析选项卡中点击数据透视图，选则柱状图，得到如下图表。</p>
<img src="https://i.imgur.com/UslC3xQ.png" alt="切片器案例一柱状图" style="zoom:80%;" />

<p>第三步，选中透视表中的任意单元格，还是在分析选项卡中，选择 插入切片器功能。在弹出的对话框中勾选 公司、年份和月份。此时会生成三个选项卡，如下图所示。此时点击选项卡上的内容时，柱状图也会发生相应的变化，从而实现快速查看分类内容。</p>
<img src="https://i.imgur.com/B4BJ4vH.png" alt="切片器案例一选项卡" style="zoom:80%;" />

<p>第四步，美化切片器。选中切片器选项卡，在 选项 菜单下，可以选择不同的切片器样式。在切片器选项卡上单击鼠标右键，可以设置切片器的大小和属性。也可以根据自己的需要关闭切片器选项卡的页眉显示。经过简单设置，最终效果如下图。</p>
<img src="https://i.imgur.com/cf0FhAi.png" alt="切片器案例一最终效果图" style="zoom:80%;" />

<h3 id="切片器案例二"><a href="#切片器案例二" class="headerlink" title="切片器案例二"></a>切片器案例二</h3><p>此案例主要介绍如何用一个切片器控制多个数据透视表。我们使用的原始数据如下图。</p>
<img src="https://i.imgur.com/AZEHn6M.png" alt="切片器案例二原始数据" style="zoom:80%;" />

<p>第一步，按照之前介绍的插入数据透视表的方法插入数据透视表。这次需要插入两次，第二次可以自己选择地方插入，插入好数据透视表后，进行简单的样式设置，最终效果如下图。</p>
<img src="https://i.imgur.com/XLYCR89.png" alt="切片器案例二插入数据透视表和图后的效果" style="zoom:80%;" />

<p>第二步，分别选中两个数据透视表，然后单击鼠标右键，选择设置数据透视表选项，修改数据透视表的名称。</p>
<p>第三步，按照前一个案例中介绍的，插入切片器选项卡，并进行简单美化。然后在切片器选项卡上单击鼠标右键，选择报表链接，然后勾选刚才命名的两个表，此时这个选项卡就可以控制两个表了。最终效果如下。</p>
<p><img src="https://i.imgur.com/ffceYo5.png" alt="切片器案例二最终效果图"></p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>数据分析</tag>
        <tag>数据透视表</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习之图表</title>
    <url>/archives/27947.html</url>
    <content><![CDATA[<h2 id="如何制作图表"><a href="#如何制作图表" class="headerlink" title="如何制作图表"></a>如何制作图表</h2><p>Excel中插入图表，首先选中数据区域，在插入选项卡中的图表区域中选择合适的图表，此时就会在表格中插入一个图表。然后在菜单栏中的设计选项卡下，点击添加元素，这里面有我们常用的图表设计的所有元素，可以根据自己的需要选择修改。</p>
<h2 id="如何制作复合图表"><a href="#如何制作复合图表" class="headerlink" title="如何制作复合图表"></a>如何制作复合图表</h2><p>复合图表是指在一个图表中，反应多个不同的信息，且不同信息的表现方式也不同，比如条形图和折线图相结合。我们假设我们要处理的数据如下图所示：</p>
<a id="more"></a>

<img src="https://i.imgur.com/ZVoPasn.png" alt="复合图表的原始数据" style="zoom:80%;" />

<p>首先我们对数据进行一些简单的分析，我们主要是要对比A、B两种产品，在2012~2016这个区间内，销量、市场总量以及市场份额的变化趋势。其次，所以我们最好是可以将A、B两种产品销量以及市场总量，堆积绘制在一起。这样可以直观的表现出两种产品销量所占的百分比，以及两种产品市场总量所占的百分比。市场份额 = 产品销量/市场总量，由于是百分比，所以最好使用折线图来表示。</p>
<p>第一步，为了绘制表格，我们需要对表格数据做一些调整，调整为下图所示。我觉得这个调整可能主要是为了绘制出的表格更加美观，相当于人为添加了表格格X轴显示区域。</p>
<p><img src="https://i.imgur.com/OiZxBVU.png" alt="调整表格数据"></p>
<p>第二步，选中销量和市场总量数据，在插入菜单栏下的图表区域，选择柱状图，在弹出的菜单中选择堆积柱状图，此时我们可以得到下图所示的表格。</p>
<p><img src="https://i.imgur.com/elUoRlv.png" alt="绘制堆积效果的柱状图"></p>
<p>第三步，选中市场份额数据表中的数据，再到图表区域点击右键，选择粘贴。此时市场份额数据就会增添到图表中了。具体的效果如下图，可以看到末尾多了市场份额的信息。</p>
<img src="https://i.imgur.com/mEK7y1x.png" alt="增加产品市场份额后的图表信息" style="zoom:80%;" />]]></content>
      <categories>
        <category>数据分析</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>数据分析</tag>
        <tag>图表</tag>
      </tags>
  </entry>
</search>
